넘파이에 오신 것을 환영합니다! 
NumPy( Numerical Python )는 거의 모든 과학 및 공학 분야에서 사용되는 오픈 소스 Python 라이브러리입니다. Python에서 숫자 데이터로 작업하기 위한 보편적인 표준이며 과학적 Python 및 PyData 생태계의 핵심입니다. NumPy 사용자에는 초보 코더부터 최첨단 과학 및 산업 연구 및 개발을 수행하는 숙련된 연구원에 이르기까지 모든 사람이 포함됩니다. NumPy API는 Pandas, SciPy, Matplotlib, scikit-learn, scikit-image 및 대부분의 기타 데이터 과학 및 과학 Python 패키지에서 광범위하게 사용됩니다.

NumPy 라이브러리에는 다차원 배열 및 행렬 데이터 구조가 포함되어 있습니다(이에 대한 자세한 내용은 이후 섹션에서 찾을 수 있습니다). 동종 n차원 배열 객체인 ndarray 를 효율적으로 작동하는 방법과 함께 제공합니다 . NumPy는 배열에서 다양한 수학적 연산을 수행하는 데 사용할 수 있습니다. 배열과 행렬로 효율적인 계산을 보장하는 강력한 데이터 구조를 Python에 추가하고 이러한 배열과 행렬에서 작동하는 고급 수학 함수의 방대한 라이브러리를 제공합니다.

여기에서 NumPy 에 대해 자세히 알아보세요 !

넘파이 설치 
NumPy를 설치하려면 과학적 Python 배포를 사용하는 것이 좋습니다. 운영 체제에 NumPy를 설치하기 위한 전체 지침을 찾고 있다면 NumPy 설치를 참조하십시오 .

Python이 이미 있는 경우 다음을 사용하여 NumPy를 설치할 수 있습니다.

conda install numpy
또는

pip install numpy
아직 Python이 없는 경우 Anaconda 사용을 고려할 수 있습니다 . 시작하는 가장 쉬운 방법입니다. 이 배포판을 얻는 것의 좋은 점은 NumPy 또는 pandas, Scikit-Learn 등과 같은 데이터 분석에 사용할 주요 패키지를 별도로 설치하는 것에 대해 너무 많이 걱정할 필요가 없다는 사실입니다.

NumPy를 가져오는 방법 
NumPy와 그 기능에 액세스하려면 다음과 같이 Python 코드에서 NumPy를 가져옵니다.

import numpy as np
npNumPy를 사용하여 코드를 더 쉽게 읽을 수 있도록 가져온 이름을 로 줄입니다 . 이것은 코드로 작업하는 모든 사람이 쉽게 이해할 수 있도록 따라야 하는 널리 채택된 규칙입니다.

예제 코드 읽기 
많은 코드가 포함된 자습서를 읽는 것이 익숙하지 않은 경우 다음과 같은 코드 블록을 해석하는 방법을 모를 수 있습니다.

a = np.arange(6)
a2 = a[np.newaxis, :]
a2.shape
(1, 6)
이 스타일에 익숙하지 않은 경우 이해하기 매우 쉽습니다. 이 표시되면 입력 또는 입력할 코드를 >>>보고 있는 것입니다 . 앞에 없는 모든 것은 출력 또는 코드 실행 결과입니다. 이것은 명령줄에서 실행할 때 표시되는 스타일 이지만 IPython을 사용하는 경우 다른 스타일이 표시될 수 있습니다. 코드의 일부가 아니며 Python 셸에 입력하거나 붙여넣으면 오류가 발생합니다. 안전하게 입력하거나 IPython 셸에 붙여넣을 수 있습니다. 무시 됩니다 .>>>python>>>

Python 목록과 NumPy 배열의 차이점은 무엇입니까? 
NumPy는 배열을 생성하고 배열 내부의 숫자 데이터를 조작하는 빠르고 효율적인 방법을 광범위하게 제공합니다. Python 목록은 단일 목록 내에 다양한 데이터 유형을 포함할 수 있지만 NumPy 배열의 모든 요소는 동질적이어야 합니다. 어레이에서 수행되어야 하는 수학적 연산은 어레이가 동질적이지 않은 경우 매우 비효율적입니다.

NumPy를 사용하는 이유는 무엇입니까?

NumPy 배열은 Python 목록보다 빠르고 작습니다. 배열은 메모리를 적게 사용하고 사용하기 편리합니다. NumPy는 데이터를 저장하는 데 훨씬 적은 메모리를 사용하며 데이터 유형을 지정하는 메커니즘을 제공합니다. 이를 통해 코드를 더욱 최적화할 수 있습니다.

배열이란 무엇입니까? 
배열은 NumPy 라이브러리의 중심 데이터 구조입니다. 배열은 값의 그리드이며 원시 데이터, 요소를 찾는 방법 및 요소를 해석하는 방법에 대한 정보를 포함합니다. 다양한 방법 으로 인덱싱할 수 있는 요소 그리드가 있습니다 . 요소는 모두 배열이라고 하는 동일한 유형입니다 dtype.

배열은 음이 아닌 정수의 튜플, 부울, 다른 배열 또는 정수로 인덱싱할 수 있습니다. rank배열의 차원 수입니다 . 배열의 는 shape각 차원을 따라 배열의 크기를 제공하는 정수의 튜플입니다.

NumPy 배열을 초기화할 수 있는 한 가지 방법은 2차원 이상의 데이터에 대해 중첩 목록을 사용하는 Python 목록에서 사용하는 것입니다.

예를 들어:

a = np.array([1, 2, 3, 4, 5, 6])
또는:

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
대괄호를 사용하여 배열의 요소에 액세스할 수 있습니다. 요소에 액세스할 때 NumPy의 인덱싱은 0부터 시작한다는 점을 기억하세요. 즉, 배열의 첫 번째 요소에 액세스하려는 경우 요소 "0"에 액세스하게 됩니다.

print(a[0])
[1 2 3 4]
배열에 대한 추가 정보 
이 섹션에서는 , , , ,1D array2D arrayndarrayvectormatrix

"N차원 배열"의 줄임말인 "ndarray"라는 배열을 가끔 들을 수 있습니다. N 차원 배열은 단순히 차원 수에 관계없이 배열입니다. 1-D 또는 1차원 배열, 2-D 또는 2차원 배열 등을 들을 수도 있습니다 . NumPy ndarray클래스는 행렬과 벡터를 모두 나타내는 데 사용됩니다. 벡터 는 1차원 배열(행 벡터와 열 벡터 간에 차이가 없음)인 반면 행렬은 2 차원 배열을 나타냅니다. 3D 이상의 차원 배열 의 경우 텐서라는 용어 도 일반적으로 사용됩니다.

배열의 속성은 무엇입니까?

배열은 일반적으로 유형 및 크기가 동일한 항목의 고정 크기 컨테이너입니다. 배열의 차원 및 항목 수는 해당 모양으로 정의됩니다. 배열의 모양은 각 차원의 크기를 지정하는 음이 아닌 정수의 튜플입니다.

NumPy에서는 차원을 축 이라고 합니다 . 이것은 다음과 같은 2D 배열이 있는 경우를 의미합니다.

[[0., 0., 0.],
 [1., 1., 1.]]
배열에는 2개의 축이 있습니다. 첫 번째 축의 길이는 2이고 두 번째 축의 길이는 3입니다.

다른 Python 컨테이너 개체와 마찬가지로 배열의 내용은 배열을 인덱싱하거나 슬라이스하여 액세스하고 수정할 수 있습니다. 일반적인 컨테이너 개체와 달리 서로 다른 배열이 동일한 데이터를 공유할 수 있으므로 한 배열에서 변경한 내용을 다른 배열에서 볼 수 있습니다.

배열 속성은 배열 자체에 고유한 정보를 반영합니다. 새 배열을 만들지 않고 배열의 속성을 가져오거나 심지어 설정해야 하는 경우 속성을 통해 배열에 액세스할 수 있습니다.

여기에서 배열 속성에 대해 자세히 읽고 여기에서 배열 개체에 대해 알아보세요 .

기본 배열을 만드는 방법 
이 섹션은 np.array() , np.zeros(), np.ones(), np.empty(), np.arange(), np.linspace(),dtype

NumPy 배열을 만들려면 함수를 사용할 수 있습니다 np.array().

간단한 배열을 만들려면 목록을 전달하기만 하면 됩니다. 원하는 경우 목록에서 데이터 유형을 지정할 수도 있습니다. 여기에서 데이터 유형에 대한 자세한 정보를 찾을 수 있습니다 .

import numpy as np
a = np.array([1, 2, 3])
다음과 같은 방법으로 배열을 시각화할 수 있습니다.

../_images/np_array.png
이러한 시각화는 아이디어를 단순화하고 NumPy 개념 및 메커니즘에 대한 기본적인 이해를 제공하기 위한 것입니다. 배열 및 배열 작업은 여기에 캡처된 것보다 훨씬 더 복잡합니다!

일련의 요소에서 배열을 만드는 것 외에도 로 채워진 배열을 쉽게 만들 수 있습니다 0.

np.zeros(2)
array([0., 0.])
또는 로 채워진 배열 1:

np.ones(2)
array([1., 1.])
또는 심지어 빈 배열! 이 함수는 empty초기 내용이 무작위이고 메모리 상태에 따라 달라지는 배열을 만듭니다. emptyover (또는 이와 유사한 것)를 사용하는 이유 zeros는 속도입니다. 나중에 모든 요소를 ​​채우십시오!

# Create an empty array with 2 elements
np.empty(2) 
array([3.14, 42.  ])  # may vary
다양한 요소로 배열을 만들 수 있습니다.

np.arange(4)
array([0, 1, 2, 3])
그리고 균일한 간격의 범위를 포함하는 배열도 있습니다. 이렇게 하려면 첫 번째 숫자 , 마지막 숫자 및 단계 크기 를 지정합니다 .

np.arange(2, 9, 2)
array([2, 4, 6, 8])
np.linspace()를 사용하여 지정된 간격으로 선형 간격을 갖는 값으로 배열을 만들 수도 있습니다 .

np.linspace(0, 10, num=5)
array([ 0. ,  2.5,  5. ,  7.5, 10. ])
데이터 유형 지정

기본 데이터 유형은 부동 소수점( np.float64)이지만 키워드를 사용하여 원하는 데이터 유형을 명시적으로 지정할 수 있습니다 dtype.

x = np.ones(2, dtype=np.int64)
x
array([1, 1])
여기에서 어레이 생성에 대해 자세히 알아보십시오.

요소 추가, 제거 및 정렬 
이 섹션에서는 np.sort() ,np.concatenate()

요소 정렬은 를 사용하면 간단합니다 np.sort(). 함수를 호출할 때 축, 종류, 순서를 지정할 수 있습니다.

이 어레이로 시작하는 경우:

arr = np.array([2, 1, 5, 3, 7, 4, 6, 8])
다음을 사용하여 숫자를 오름차순으로 빠르게 정렬할 수 있습니다.

np.sort(arr)
array([1, 2, 3, 4, 5, 6, 7, 8])
배열의 정렬된 복사본을 반환하는 정렬 외에도 다음을 사용할 수 있습니다.

argsort지정된 축을 따라 간접적으로 정렬하는 ,

lexsort, 여러 키에 대한 간접 안정적인 정렬,

searchsorted, 정렬된 배열에서 요소를 찾습니다.

partition, 부분 정렬입니다.

배열 정렬에 대한 자세한 내용은 다음을 참조하십시오 sort.

다음 어레이로 시작하는 경우:

a = np.array([1, 2, 3, 4])
b = np.array([5, 6, 7, 8])
로 연결할 수 있습니다 np.concatenate().

np.concatenate((a, b))
array([1, 2, 3, 4, 5, 6, 7, 8])
또는 다음 어레이로 시작하는 경우:

x = np.array([[1, 2], [3, 4]])
y = np.array([[5, 6]])
다음과 연결할 수 있습니다.

np.concatenate((x, y), axis=0)
array([[1, 2],
       [3, 4],
       [5, 6]])
배열에서 요소를 제거하려면 인덱싱을 사용하여 유지하려는 요소를 선택하는 것이 간단합니다.

연결에 대한 자세한 내용은 다음을 참조하십시오 concatenate.

배열의 모양과 크기를 어떻게 알 수 있습니까? 
이 섹션에서는 ndarray.ndim , ndarray.size,ndarray.shape

ndarray.ndim배열의 축 또는 차원 수를 알려줍니다.

ndarray.size배열의 총 요소 수를 알려줍니다. 이것은 배열 모양 요소의 곱 입니다.

ndarray.shape배열의 각 차원을 따라 저장된 요소 수를 나타내는 정수 튜플을 표시합니다. 예를 들어 2행 3열의 2차원 배열이 있는 경우 배열의 모양은 입니다 .(2, 3)

예를 들어, 다음 어레이를 생성하는 경우:

array_example = np.array([[[0, 1, 2, 3],
                           [4, 5, 6, 7]],

                          [[0, 1, 2, 3],
                           [4, 5, 6, 7]],

                          [[0 ,1 ,2, 3],
                           [4, 5, 6, 7]]])
배열의 차원 수를 찾으려면 다음을 실행하십시오.

array_example.ndim
3
배열의 총 요소 수를 찾으려면 다음을 실행하십시오.

array_example.size
24
배열의 모양을 찾으려면 다음을 실행하십시오.

array_example.shape
(3, 2, 4)
배열을 재구성할 수 있습니까? 
이 섹션에서는 arr.reshape()

예!

를 사용하면 arr.reshape()데이터를 변경하지 않고 배열에 새로운 모양을 부여할 수 있습니다. reshape 방법을 사용할 때 생성하려는 배열은 원래 배열과 동일한 수의 요소를 가져야 한다는 점을 기억하십시오. 12개의 요소가 있는 배열로 시작하는 경우 새 배열에도 총 12개의 요소가 있는지 확인해야 합니다.

이 어레이로 시작하는 경우:

a = np.arange(6)
print(a)
[0 1 2 3 4 5]
reshape()배열을 재구성하는 데 사용할 수 있습니다 . 예를 들어 이 배열을 3개의 행과 2개의 열이 있는 배열로 재구성할 수 있습니다.

b = a.reshape(3, 2)
print(b)
[[0 1]
 [2 3]
 [4 5]]
를 사용하여 np.reshape몇 가지 선택적 매개변수를 지정할 수 있습니다.

np.reshape(a, newshape=(1, 6), order='C')
array([[0, 1, 2, 3, 4, 5]])
a재구성할 배열입니다.

newshape당신이 원하는 새로운 모양입니다. 정수 또는 정수 튜플을 지정할 수 있습니다. 정수를 지정하면 결과는 해당 길이의 배열이 됩니다. 모양은 원래 모양과 호환되어야 합니다.

order: CC와 같은 인덱스 순서를 사용하여 요소를 읽고 쓴다는 의미 F포트란과 같은 인덱스 순서를 사용하여 요소 A 를 읽고 쓴다는 의미 a가 메모리에서 포트란 연속인 경우 포트란과 같은 인덱스 순서로 요소를 읽고 쓴다는 것을 의미 C -그렇지 않은 순서. (이는 선택적 매개변수이며 지정할 필요가 없습니다.)

C 및 Fortran 순서에 대해 자세히 알아보려면 여기에서 NumPy 배열의 내부 구성에 대해 자세히 알아볼 수 있습니다 . 기본적으로 C 및 Fortran 주문은 배열이 메모리에 저장되는 순서에 인덱스가 어떻게 대응하는지와 관련이 있습니다. Fortran에서 메모리에 저장되어 있는 2차원 배열의 요소 사이를 이동할 때 첫 번째 인덱스는 가장 빠르게 변하는 인덱스입니다. 첫 번째 인덱스가 변경됨에 따라 다음 행으로 이동하므로 행렬은 한 번에 한 열씩 저장됩니다. 이것이 Fortran이 Column-major 언어 로 생각되는 이유입니다 . 반면 C에서는 마지막 인덱스가 가장 빠르게 변경됩니다. 행렬은 행별로 저장되므로 행 주요 언어가 됩니다.. C 또는 Fortran에서 수행하는 작업은 인덱싱 규칙을 유지하는 것이 더 중요한지 또는 데이터를 재정렬하지 않는 것이 더 중요한지에 따라 다릅니다.

여기에서 모양 조작에 대해 자세히 알아보세요 .

1D 배열을 2D 배열로 변환하는 방법(배열에 새 축을 추가하는 방법) 
이 섹션에서는 np.newaxis ,np.expand_dims

np.newaxis및 를 사용하여 np.expand_dims기존 어레이의 크기를 늘릴 수 있습니다.

를 사용하면 np.newaxis한 번 사용할 때 배열의 크기가 한 차원 증가합니다. 즉, 1D 배열은 2D 배열이 되고 2D 배열은 3D 배열이 됩니다 .

예를 들어 다음 배열로 시작하는 경우:

a = np.array([1, 2, 3, 4, 5, 6])
a.shape
(6,)
np.newaxis다음을 사용하여 새 축을 추가 할 수 있습니다 .

a2 = a[np.newaxis, :]
a2.shape
(1, 6)
를 사용하여 행 벡터 또는 열 벡터가 있는 1D 배열을 명시적으로 변환할 수 있습니다 np.newaxis. 예를 들어 첫 번째 차원을 따라 축을 삽입하여 1D 배열을 행 벡터로 변환할 수 있습니다.

row_vector = a[np.newaxis, :]
row_vector.shape
(1, 6)
또는 열 벡터의 경우 두 번째 차원을 따라 축을 삽입할 수 있습니다.

col_vector = a[:, np.newaxis]
col_vector.shape
(6, 1)
를 사용하여 지정된 위치에 새 축을 삽입하여 배열을 확장할 수도 있습니다 np.expand_dims.

예를 들어 다음 배열로 시작하는 경우:

a = np.array([1, 2, 3, 4, 5, 6])
a.shape
(6,)
np.expand_dims다음을 사용하여 인덱스 위치 1에 축을 추가하는 데 사용할 수 있습니다 .

b = np.expand_dims(a, axis=1)
b.shape
(6, 1)
다음을 사용하여 인덱스 위치 0에 축을 추가할 수 있습니다.

c = np.expand_dims(a, axis=0)
c.shape
(1, 6)
여기 와 expand_dims에서 newaxis 에 대한 자세한 정보를 찾으십시오 expand_dims.

인덱싱 및 슬라이싱 
Python 목록을 슬라이스하는 것과 같은 방식으로 NumPy 배열을 인덱싱하고 슬라이스할 수 있습니다.

data = np.array([1, 2, 3])

data[1]
2
data[0:2]
array([1, 2])
data[1:]
array([2, 3])
data[-2:]
array([2, 3])
다음과 같이 시각화할 수 있습니다.

../_images/np_indexing.png
추가 분석이나 추가 작업에 사용할 배열 또는 특정 배열 요소의 섹션을 가져오고 싶을 수 있습니다. 그렇게 하려면 배열을 하위 집합, 슬라이스 및/또는 인덱싱해야 합니다.

배열에서 특정 조건을 충족하는 값을 선택하려는 경우 NumPy를 사용하면 간단합니다.

예를 들어 다음 배열로 시작하는 경우:

a = np.array([[1 , 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
5보다 작은 배열의 모든 값을 쉽게 인쇄할 수 있습니다.

print(a[a < 5])
[1 2 3 4]
예를 들어 5보다 크거나 같은 숫자를 선택하고 해당 조건을 사용하여 배열을 인덱싱할 수도 있습니다.

five_up = (a >= 5)
print(a[five_up])
[ 5  6  7  8  9 10 11 12]
2로 나눌 수 있는 요소를 선택할 수 있습니다.

divisible_by_2 = a[a%2==0]
print(divisible_by_2)
[ 2  4  6  8 10 12]
&또는 and 연산자를 사용하여 두 가지 조건을 만족하는 요소를 선택할 수 있습니다 | .

c = a[(a > 2) & (a < 11)]
print(c)
[ 3  4  5  6  7  8  9 10]
논리 연산자 & 및 |를 사용할 수도 있습니다. 배열의 값이 특정 조건을 충족하는지 여부를 지정하는 부울 값을 반환하기 위해. 이는 이름이나 기타 범주 값을 포함하는 배열에 유용할 수 있습니다.

five_up = (a > 5) | (a == 5)
print(five_up)
[[False False False False]
 [ True  True  True  True]
 [ True  True  True True]]
np.nonzero()배열에서 요소나 인덱스를 선택하는 데 사용할 수도 있습니다 .

이 어레이로 시작:

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
np.nonzero()예를 들어 5보다 작은 요소의 인덱스를 인쇄하는 데 사용할 수 있습니다 .

b = np.nonzero(a < 5)
print(b)
(array([0, 0, 0, 0]), array([0, 1, 2, 3]))
이 예에서는 각 차원에 대해 하나씩 배열의 튜플이 반환되었습니다. 첫 번째 배열은 이러한 값이 있는 행 인덱스를 나타내고 두 번째 배열은 값이 있는 열 인덱스를 나타냅니다.

요소가 존재하는 좌표 목록을 생성하려면 배열을 압축하고 좌표 목록을 반복하여 인쇄할 수 있습니다. 예를 들어:

list_of_coordinates= list(zip(b[0], b[1]))

for coord in list_of_coordinates:
    print(coord)
(0, 0)
(0, 1)
(0, 2)
(0, 3)
np.nonzero()다음을 사용하여 5보다 작은 배열의 요소를 인쇄하는 데 사용할 수도 있습니다 .

print(a[b])
[1 2 3 4]
찾으려는 요소가 배열에 없으면 반환된 인덱스 배열은 비어 있습니다. 예를 들어:

not_there = np.nonzero(a == 42)
print(not_there)
(array([], dtype=int64), array([], dtype=int64))
인덱싱 및 슬라이싱 에 대한 자세한 내용은 여기 및 여기를 참조하십시오 .

0이 아닌 함수 사용에 대한 자세한 내용은 다음을 참조하십시오 nonzero.

기존 데이터에서 배열을 만드는 방법 
이 섹션에서는 , , , , ,slicing and indexingnp.vstack()np.hstack()np.hsplit().view()copy()

기존 배열의 섹션에서 새 배열을 쉽게 만들 수 있습니다.

다음과 같은 배열이 있다고 가정해 보겠습니다.

a = np.array([1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
배열을 분할할 위치를 지정하여 언제든지 배열 섹션에서 새 배열을 만들 수 있습니다.

arr1 = a[3:8]
arr1
array([4, 5, 6, 7, 8])
여기에서 인덱스 위치 3에서 인덱스 위치 8까지 배열의 섹션을 가져왔습니다.

수직 및 수평으로 두 개의 기존 어레이를 쌓을 수도 있습니다. a1두 개의 배열이 있고 다음과 같이 가정합니다 a2.

a1 = np.array([[1, 1],
               [2, 2]])

a2 = np.array([[3, 3],
               [4, 4]])
다음을 사용하여 세로로 쌓을 수 있습니다 vstack.

np.vstack((a1, a2))
array([[1, 1],
       [2, 2],
       [3, 3],
       [4, 4]])
또는 다음을 사용하여 가로로 쌓으십시오 hstack.

np.hstack((a1, a2))
array([[1, 1, 3, 3],
       [2, 2, 4, 4]])
를 사용하여 어레이를 여러 개의 작은 어레이로 분할할 수 있습니다 hsplit. 반환할 모양이 같은 배열의 수 또는 분할이 발생해야 하는 열을 지정할 수 있습니다 .

다음과 같은 배열이 있다고 가정해 보겠습니다.

x = np.arange(1, 25).reshape(2, 12)
x
array([[ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12],
       [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]])
이 배열을 3개의 동일한 모양의 배열로 분할하려면 다음을 실행합니다.

np.hsplit(x, 3)
  [array([[ 1,  2,  3,  4],
         [13, 14, 15, 16]]), array([[ 5,  6,  7,  8],
         [17, 18, 19, 20]]), array([[ 9, 10, 11, 12],
         [21, 22, 23, 24]])]
세 번째와 네 번째 열 다음에 배열을 분할하려면 다음을 실행합니다.

np.hsplit(x, (3, 4))
  [array([[ 1,  2,  3],
         [13, 14, 15]]), array([[ 4],
         [16]]), array([[ 5,  6,  7,  8,  9, 10, 11, 12],
         [17, 18, 19, 20, 21, 22, 23, 24]])]
여기에서 어레이 스태킹 및 분할에 대해 자세히 알아보십시오 .

view이 메서드를 사용하여 원본 배열과 동일한 데이터를 보는 새 배열 개체를 만들 수 있습니다( 얕은 복사본 ).

뷰는 NumPy의 중요한 개념입니다! 인덱싱 및 슬라이싱과 같은 작업뿐만 아니라 NumPy 함수는 가능할 때마다 뷰를 반환합니다. 이렇게 하면 메모리가 절약되고 속도가 빨라집니다(데이터를 복사할 필요가 없음). 그러나 이를 인식하는 것이 중요합니다. 뷰에서 데이터를 수정하면 원래 배열도 수정됩니다!

이 배열을 만든다고 가정해 보겠습니다.

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
이제 의 첫 번째 요소를 b1슬라이스 하고 수정하여 배열을 만듭니다 . 이렇게 하면 해당 요소 도 수정됩니다!ab1a

b1 = a[0, :]
b1
array([1, 2, 3, 4])
b1[0] = 99
b1
array([99,  2,  3,  4])
a
array([[99,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
이 copy방법을 사용하면 어레이와 해당 데이터의 완전한 복사본이 만들어집니다( 깊은 복사본 ). 어레이에서 이것을 사용하려면 다음을 실행할 수 있습니다.

b2 = a.copy()
여기에서 사본 및 보기에 대해 자세히 알아보십시오 .

기본 배열 작업 
이 섹션에서는 더하기, 빼기, 곱하기, 나누기 등을 다룹니다.

배열을 만든 후에는 작업을 시작할 수 있습니다. 예를 들어 "data"와 "ones"라는 두 개의 배열을 만들었다고 가정해 보겠습니다.

../_images/np_array_dataones.png
더하기 기호와 함께 배열을 추가할 수 있습니다.

data = np.array([1, 2])
ones = np.ones(2, dtype=int)
data + ones
array([2, 3])
../_images/np_data_plus_ones.png
물론 단순히 더하는 것 이상을 할 수 있습니다!

data - ones
array([0, 1])
data * data
array([1, 4])
data / data
array([1., 1.])
../_images/np_sub_mult_divide.png
NumPy를 사용하면 기본 작업이 간단합니다. 배열의 요소 합계를 찾으려면 sum(). 이것은 1D 배열, 2D 배열 및 더 높은 차원의 배열에서 작동합니다.

a = np.array([1, 2, 3, 4])

a.sum()
10
2D 배열에 행이나 열을 추가하려면 축을 지정합니다.

이 어레이로 시작하는 경우:

b = np.array([[1, 1], [2, 2]])
다음을 사용하여 행 축을 합산할 수 있습니다.

b.sum(axis=0)
array([3, 3])
다음을 사용하여 열 축을 합산할 수 있습니다.

b.sum(axis=1)
array([2, 4])
여기에서 기본 작업에 대해 자세히 알아보십시오 .

방송 
배열과 단일 숫자 간 연산( 벡터와 스칼라 간 연산 이라고도 함 ) 또는 크기가 다른 두 배열 간에 연산을 수행해야 하는 경우가 있습니다 . 예를 들어 배열("데이터"라고 함)에 마일 단위의 거리 정보가 포함될 수 있지만 해당 정보를 킬로미터로 변환하려고 합니다. 다음을 사용하여 이 작업을 수행할 수 있습니다.

data = np.array([1.0, 2.0])
data * 1.6
array([1.6, 3.2])
../_images/np_multiply_broadcasting.png
NumPy는 곱셈이 각 셀에서 발생해야 한다는 것을 이해합니다. 그 개념을 브로드캐스팅 이라고 합니다 . 브로드캐스팅은 NumPy가 다양한 모양의 배열에서 작업을 수행할 수 있도록 하는 메커니즘입니다. 예를 들어 두 배열의 차원이 같거나 둘 중 하나가 1인 경우 배열의 차원이 호환되어야 합니다. 차원이 호환되지 않으면 ValueError.

여기에서 방송에 대해 자세히 알아보십시오 .

더 유용한 배열 작업 
이 섹션에서는 최대값, 최소값, 합계, 평균, 제품, 표준편차 등을 다룹니다.

NumPy는 집계 기능도 수행합니다. min, max, 및 외에도 sum쉽게 실행하여 mean평균 구하기, prod요소를 함께 곱한 결과 얻기, std표준 편차 구하기 등을 수행할 수 있습니다.

data.max()
2.0
data.min()
1.0
data.sum()
3.0
../_images/np_aggregation.png
"a"라고 하는 이 배열부터 시작하겠습니다.

a = np.array([[0.45053314, 0.17296777, 0.34376245, 0.5510652],
              [0.54627315, 0.05093587, 0.40067661, 0.55645993],
              [0.12697628, 0.82485143, 0.26590556, 0.56917101]])
행이나 열을 따라 집계하려는 것은 매우 일반적입니다. 기본적으로 모든 NumPy 집계 함수는 전체 배열의 집계를 반환합니다. 배열에 있는 요소의 합계 또는 최소값을 찾으려면 다음을 실행하십시오.

a.sum()
4.8595784
또는:

a.min()
0.05093587
집계 함수를 계산할 축을 지정할 수 있습니다. 예를 들어 를 지정하여 각 열 내에서 최소값을 찾을 수 있습니다 axis=0.

a.min(axis=0)
array([0.12697628, 0.05093587, 0.26590556, 0.5510652 ])
위에 나열된 네 개의 값은 배열의 열 수에 해당합니다. 4열 배열을 사용하면 결과로 4개의 값을 얻게 됩니다.

배열 방법 에 대한 자세한 내용은 여기를 참조하십시오 .

행렬 만들기 
목록의 Python 목록을 전달하여 2차원 배열(또는 "매트릭스")을 만들어 NumPy에서 나타낼 수 있습니다.

data = np.array([[1, 2], [3, 4], [5, 6]])
data
array([[1, 2],
       [3, 4],
       [5, 6]])
../_images/np_create_matrix.png
인덱싱 및 슬라이싱 작업은 행렬을 조작할 때 유용합니다.

data[0, 1]
2
data[1:3]
array([[3, 4],
       [5, 6]])
data[0:2, 0]
array([1, 3])
../_images/np_matrix_indexing.png
벡터를 집계한 것과 같은 방식으로 행렬을 집계할 수 있습니다.

data.max()
6
data.min()
1
data.sum()
21
../_images/np_matrix_aggregation.png
행렬의 모든 값을 집계할 수 있으며 매개 axis변수를 사용하여 열 또는 행에서 값을 집계할 수 있습니다. 이 점을 설명하기 위해 약간 수정된 데이터 세트를 살펴보겠습니다.

data = np.array([[1, 2], [5, 3], [4, 6]])
data
array([[1, 2],
       [5, 3],
       [4, 6]])
data.max(axis=0)
array([5, 6])
data.max(axis=1)
array([2, 5, 6])
../_images/np_matrix_aggregation_row.png
행렬을 만든 후에는 크기가 같은 두 개의 행렬이 있는 경우 산술 연산자를 사용하여 더하고 곱할 수 있습니다.

data = np.array([[1, 2], [3, 4]])
ones = np.array([[1, 1], [1, 1]])
data + ones
array([[2, 3],
       [4, 5]])
../_images/np_matrix_arithmetic.png
크기가 다른 행렬에 대해 이러한 산술 연산을 수행할 수 있지만, 하나의 행렬에 하나의 열 또는 하나의 행만 있는 경우에만 가능합니다. 이 경우 NumPy는 작업에 브로드캐스트 규칙을 사용합니다.

data = np.array([[1, 2], [3, 4], [5, 6]])
ones_row = np.array([[1, 1]])
data + ones_row
array([[2, 3],
       [4, 5],
       [6, 7]])
../_images/np_matrix_broadcasting.png
NumPy가 N차원 배열을 인쇄할 때 마지막 축이 가장 빠르게 반복되고 첫 번째 축이 가장 느립니다. 예를 들어:

np.ones((4, 3, 2))
array([[[1., 1.],
        [1., 1.],
        [1., 1.]],

       [[1., 1.],
        [1., 1.],
        [1., 1.]],

       [[1., 1.],
        [1., 1.],
        [1., 1.]],

       [[1., 1.],
        [1., 1.],
        [1., 1.]]])
NumPy가 배열의 값을 초기화하기를 원하는 경우가 종종 있습니다. ones()NumPy는 및 와 같은 함수 zeros()와 random.Generator이를 위한 난수 생성 클래스를 제공합니다. 생성할 요소 수를 전달하기만 하면 됩니다.

np.ones(3)
array([1., 1., 1.])
np.zeros(3)
array([0., 0., 0.])
rng = np.random.default_rng()  # the simplest way to generate random numbers
rng.random(3) 
array([0.63696169, 0.26978671, 0.04097352])
../_images/np_ones_zeros_random.png
행렬의 차원을 설명하는 튜플을 제공하는 경우 ones(), zeros()및 를 사용하여 2D 배열을 만들 수도 있습니다 .random()

np.ones((3, 2))
array([[1., 1.],
       [1., 1.],
       [1., 1.]])
np.zeros((3, 2))
array([[0., 0.],
       [0., 0.],
       [0., 0.]])
rng.random((3, 2)) 
array([[0.01652764, 0.81327024],
       [0.91275558, 0.60663578],
       [0.72949656, 0.54362499]])  # may vary
../_images/np_ones_zeros_matrix.png
0배열 생성 루틴 에서 's, 's, 기타 값 으로 채워지 1거나 초기화되지 않은 배열 생성 에 대해 자세히 읽어보십시오 .

난수 생성 
난수 생성의 사용은 많은 수치 및 기계 학습 알고리즘의 구성 및 평가에서 중요한 부분입니다. 인공 신경망에서 가중치를 임의로 초기화해야 하는지, 데이터를 임의 집합으로 분할해야 하는지 또는 데이터 집합을 무작위로 섞을지 여부에 관계없이 난수(실제로는 반복 가능한 의사 난수)를 생성할 수 있어야 합니다.

를 사용하면 Generator.integers낮음(NumPy에 포함됨)에서 높음(제외)까지 임의의 정수를 생성할 수 있습니다. endpoint=True높은 숫자를 포함하도록 설정할 수 있습니다 .

다음을 사용하여 0과 4 사이의 임의 정수로 구성된 2 x 4 배열을 생성할 수 있습니다.

rng.integers(5, size=(2, 4)) 
array([[2, 1, 1, 0],
       [0, 0, 0, 4]])  # may vary
난수 생성에 대한 자세한 내용은 여기를 참조하십시오 .

고유 아이템 및 카운트를 얻는 방법 
이 섹션에서는 np.unique()

를 사용하여 배열의 고유한 요소를 쉽게 찾을 수 있습니다 np.unique.

예를 들어 다음 배열로 시작하는 경우:

a = np.array([11, 11, 12, 13, 14, 15, 16, 17, 12, 13, 11, 14, 18, 19, 20])
np.unique배열의 고유 값을 인쇄하는 데 사용할 수 있습니다 .

unique_values = np.unique(a)
print(unique_values)
[11 12 13 14 15 16 17 18 19 20]
NumPy 배열(배열에서 고유한 값의 첫 번째 인덱스 위치 배열)에서 고유한 값의 인덱스를 얻으려면 인수 return_index 와 np.unique()배열을 전달하면 됩니다.

unique_values, indices_list = np.unique(a, return_index=True)
print(indices_list)
[ 0  2  3  4  5  6  7 12 13 14]
return_counts배열과 함께 인수를 전달하여 np.unique()NumPy 배열에서 고유한 값의 빈도 수를 얻을 수 있습니다.

unique_values, occurrence_count = np.unique(a, return_counts=True)
print(occurrence_count)
[3 2 2 2 1 1 1 1 1 1]
이것은 2D 배열에서도 작동합니다! 이 어레이로 시작하는 경우:

a_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [1, 2, 3, 4]])
다음을 사용하여 고유한 값을 찾을 수 있습니다.

unique_values = np.unique(a_2d)
print(unique_values)
[ 1  2  3  4  5  6  7  8  9 10 11 12]
축 인수가 전달되지 않으면 2D 배열이 평면화됩니다.

고유한 행이나 열을 가져오려면 axis 인수를 전달해야 합니다. 고유한 행을 찾으려면 을 지정 axis=0하고 열에 대해 를 지정하십시오 axis=1.

unique_rows = np.unique(a_2d, axis=0)
print(unique_rows)
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]
고유 행, 인덱스 위치 및 발생 횟수를 얻으려면 다음을 사용할 수 있습니다.

unique_rows, indices, occurrence_count = np.unique(
     a_2d, axis=0, return_counts=True, return_index=True)
print(unique_rows)
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]
print(indices)
[0 1 2]
print(occurrence_count)
[2 1 1]
배열에서 고유한 요소를 찾는 방법에 대한 자세한 내용은 을 참조하십시오 unique.

행렬 전치 및 변형 
이 섹션에서는 arr.reshape() , arr.transpose(),arr.T

행렬을 바꿔야 하는 것이 일반적입니다. TNumPy 배열에는 행렬을 바꿀 수 있는 속성이 있습니다 .

../_images/np_transposing_reshaping.png
행렬의 차원을 전환해야 할 수도 있습니다. 예를 들어 데이터 세트와 다른 특정 입력 형태를 예상하는 모델이 있는 경우 이러한 상황이 발생할 수 있습니다. 이 reshape방법이 유용할 수 있는 곳입니다. 행렬에 대해 원하는 새 차원을 전달하기만 하면 됩니다.

data.reshape(2, 3)
array([[1, 2, 3],
       [4, 5, 6]])
data.reshape(3, 2)
array([[1, 2],
       [3, 4],
       [5, 6]])
../_images/np_reshape.png
.transpose()지정한 값에 따라 배열의 축을 뒤집거나 변경하는 데 사용할 수도 있습니다 .

이 어레이로 시작하는 경우:

arr = np.arange(6).reshape((2, 3))
arr
array([[0, 1, 2],
       [3, 4, 5]])
를 사용하여 배열을 바꿀 수 있습니다 arr.transpose().

arr.transpose()
array([[0, 3],
       [1, 4],
       [2, 5]])
다음을 사용할 수도 있습니다 arr.T.

arr.T
array([[0, 3],
       [1, 4],
       [2, 5]])
배열 전치 및 형태 변경에 대한 자세한 내용은 transpose및 를 참조하십시오 reshape.

배열을 뒤집는 방법 
이 섹션에서는 np.flip()

NumPy의 np.flip()기능을 사용하면 축을 따라 배열의 내용을 뒤집거나 뒤집을 수 있습니다. 를 사용할 때 np.flip()반전하려는 배열과 축을 지정합니다. 축을 지정하지 않으면 NumPy는 입력 배열의 모든 축을 따라 내용을 뒤집습니다.

1D 배열 뒤집기

다음과 같은 1D 배열로 시작하는 경우:

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
다음과 같이 되돌릴 수 있습니다.

reversed_arr = np.flip(arr)
반전된 배열을 인쇄하려면 다음을 실행할 수 있습니다.

print('Reversed Array: ', reversed_arr)
Reversed Array:  [8 7 6 5 4 3 2 1]
2D 배열 뒤집기

2D 배열은 거의 같은 방식으로 작동합니다.

이 어레이로 시작하는 경우:

arr_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
다음을 사용하여 모든 행과 모든 열의 내용을 뒤집을 수 있습니다.

reversed_arr = np.flip(arr_2d)
print(reversed_arr)
[[12 11 10  9]
 [ 8  7  6  5]
 [ 4  3  2  1]]
다음을 사용하여 행만 쉽게 뒤집을 수 있습니다 .

reversed_arr_rows = np.flip(arr_2d, axis=0)
print(reversed_arr_rows)
[[ 9 10 11 12]
 [ 5  6  7  8]
 [ 1  2  3  4]]
또는 다음을 사용하여 열만 뒤집습니다.

reversed_arr_columns = np.flip(arr_2d, axis=1)
print(reversed_arr_columns)
[[ 4  3  2  1]
 [ 8  7  6  5]
 [12 11 10  9]]
한 열이나 행의 내용만 뒤집을 수도 있습니다. 예를 들어 인덱스 위치 1(두 번째 행)에 있는 행의 내용을 뒤집을 수 있습니다.

arr_2d[1] = np.flip(arr_2d[1])
print(arr_2d)
[[ 1  2  3  4]
 [ 8  7  6  5]
 [ 9 10 11 12]]
인덱스 위치 1(두 번째 열)의 열을 뒤집을 수도 있습니다.

arr_2d[:,1] = np.flip(arr_2d[:,1])
print(arr_2d)
[[ 1 10  3  4]
 [ 8  7  6  5]
 [ 9  2 11 12]]
에서 배열 반전에 대해 자세히 읽어보십시오 flip.

다차원 배열 재구성 및 평면화 
이 섹션에서는 .flatten() ,ravel()

배열을 평면화하는 두 가지 인기 있는 방법이 있습니다: .flatten()및 .ravel(). 둘 사이의 주요 차이점은 사용하여 생성된 새 배열이 ravel()실제로는 부모 배열(예: "뷰")에 대한 참조라는 것입니다. 이는 새 어레이에 대한 모든 변경 사항이 상위 어레이에도 영향을 미친다는 것을 의미합니다. ravel사본을 만들지 않기 때문에 메모리 효율적입니다.

이 어레이로 시작하는 경우:

x = np.array([[1 , 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
flatten배열을 1D 배열로 평면화하는 데 사용할 수 있습니다 .

x.flatten()
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])
를 사용할 때 flatten새 배열을 변경해도 상위 배열은 변경되지 않습니다.

예를 들어:

a1 = x.flatten()
a1[0] = 99
print(x)  # Original array
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]
print(a1)  # New array
[99  2  3  4  5  6  7  8  9 10 11 12]
그러나 를 사용하면 ravel새 어레이에 대한 변경 사항이 상위 어레이에 영향을 미칩니다.

예를 들어:

a2 = x.ravel()
a2[0] = 98
print(x)  # Original array
[[98  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]
print(a2)  # New array
[98  2  3  4  5  6  7  8  9 10 11 12]
flattenat ndarray.flatten및 ravelat 에 대해 자세히 알아보세요 ravel.

자세한 정보를 위해 docstring에 액세스하는 방법 
이 섹션에서는 help() , ?,??

데이터 과학 생태계와 관련하여 Python과 NumPy는 사용자를 염두에 두고 구축되었습니다. 이것의 가장 좋은 예 중 하나는 문서에 대한 기본 제공 액세스입니다. 모든 개체에는 docstring 이라고 하는 문자열에 대한 참조가 포함되어 있습니다 . 대부분의 경우 이 docstring에는 객체에 대한 빠르고 간결한 요약과 사용 방법이 포함되어 있습니다. help() Python에는 이 정보에 액세스하는 데 도움이 되는 내장 함수가 있습니다 . 즉, 추가 정보가 필요할 때마다 help()필요한 정보를 빠르게 찾는 데 사용할 수 있습니다.

예를 들어:

help(max)
Help on built-in function max in module builtins:

max(...)
    max(iterable, *[, default=obj, key=func]) -> value
    max(arg1, arg2, *args, *[, key=func]) -> value

    With a single iterable argument, return its biggest item. The
    default keyword-only argument specifies an object to return if
    the provided iterable is empty.
    With two or more arguments, return the largest argument.
? 추가 정보에 대한 액세스가 매우 유용하기 때문에 IPython은 다른 관련 정보와 함께 이 문서에 액세스하기 위한 속기로 문자를 사용합니다 . IPython은 여러 언어로 대화형 컴퓨팅을 위한 명령 셸입니다. 여기에서 IPython에 대한 자세한 정보를 찾을 수 있습니다 .

예를 들어:

max?
max(iterable, *[, default=obj, key=func]) -> value
max(arg1, arg2, *args, *[, key=func]) -> value

With a single iterable argument, return its biggest item. The
default keyword-only argument specifies an object to return if
the provided iterable is empty.
With two or more arguments, return the largest argument.
Type:      builtin_function_or_method
객체 메서드와 객체 자체에도 이 표기법을 사용할 수 있습니다.

이 배열을 만든다고 가정해 보겠습니다.

a = np.array([1, 2, 3, 4, 5, 6])
그런 다음 많은 유용한 정보를 얻을 수 있습니다(먼저 자신에 대한 세부 정보 , 인스턴스 인 a독스트링이 뒤따름 ).ndarraya

a?
Type:            ndarray
String form:     [1 2 3 4 5 6]
Length:          6
File:            ~/anaconda3/lib/python3.9/site-packages/numpy/__init__.py
Docstring:       <no docstring>
Class docstring:
ndarray(shape, dtype=float, buffer=None, offset=0,
        strides=None, order=None)

An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)

Arrays should be constructed using `array`, `zeros` or `empty` (refer
to the See Also section below).  The parameters given here refer to
a low-level method (`ndarray(...)`) for instantiating an array.

For more information, refer to the `numpy` module and examine the
methods and attributes of an array.

Parameters
----------
(for the __new__ method; see Notes below)

shape : tuple of ints
        Shape of created array.
...
이는 사용자가 생성하는 함수 및 기타 개체에도 적용됩니다 . 문자열 리터럴( 또는 문서 주변)을 사용하여 함수에 독스트링을 포함하는 것을 잊지 마십시오 .""" """''' '''

예를 들어 다음 함수를 생성하는 경우:

def double(a):
  '''Return a * 2'''
  return a * 2
기능에 대한 정보를 얻을 수 있습니다.

double?
Signature: double(a)
Docstring: Return a * 2
File:      ~/Desktop/<ipython-input-23-b5adf20be596>
Type:      function
관심 있는 개체의 소스 코드를 읽으면 다른 수준의 정보에 도달할 수 있습니다. 이중 물음표( ??)를 사용하면 소스 코드에 액세스할 수 있습니다.

예를 들어:

double??
Signature: double(a)
Source:
def double(a):
    '''Return a * 2'''
    return a * 2
File:      ~/Desktop/<ipython-input-23-b5adf20be596>
Type:      function
해당 개체가 Python 이외의 언어로 컴파일된 경우 using은 와 ??동일한 정보를 반환합니다 ?. 예를 들어 다음과 같은 많은 내장 객체 및 유형에서 이를 찾을 수 있습니다.

len?
Signature: len(obj, /)
Docstring: Return the number of items in a container.
Type:      builtin_function_or_method
그리고 :

len??
Signature: len(obj, /)
Docstring: Return the number of items in a container.
Type:      builtin_function_or_method
Python 이외의 프로그래밍 언어로 컴파일되었기 때문에 동일한 출력을 갖습니다.

수학 공식 작업 
배열에서 작동하는 수학 공식을 쉽게 구현할 수 있다는 점은 NumPy가 과학 Python 커뮤니티에서 널리 사용되는 이유 중 하나입니다.

예를 들어, 다음은 평균 제곱 오차 공식(회귀를 처리하는 감독 기계 학습 모델에 사용되는 중심 공식)입니다.

../_images/np_MSE_formula.png
NumPy에서 이 공식을 구현하는 것은 간단하고 간단합니다.

../_images/np_MSE_implementation.png
이 작업이 잘 작동하는 이유는 하나 또는 수천 개의 값을 포함할 수 있다는 predictions것 입니다. labels크기만 같으면 됩니다.

다음과 같이 시각화할 수 있습니다.

../_images/np_mse_viz1.png
이 예에서 예측 벡터와 레이블 벡터는 모두 3개의 값을 포함하며, 의미는 n3의 값을 가집니다. 빼기를 수행한 후 벡터의 값은 제곱됩니다. 그런 다음 NumPy는 값을 합산하고 결과는 해당 예측에 대한 오류 값과 모델 품질에 대한 점수입니다.

../_images/np_mse_viz2.png ../_images/np_MSE_explanation2.png
NumPy 객체를 저장하고 로드하는 방법 
이 섹션에서는 np.save , np.savez, np.savetxt, np.load,np.loadtxt

언젠가는 어레이를 디스크에 저장하고 코드를 다시 실행할 필요 없이 다시 로드하고 싶을 것입니다. 다행스럽게도 NumPy로 객체를 저장하고 로드하는 방법에는 여러 가지가 있습니다. ndarray 객체는 일반 텍스트 파일을 처리하는 함수, loadtxt파일 확장자 가 .npy 인 NumPy 바이너리 파일을 처리하는 함수 , 파일 확장자 가 .npz 인 NumPy 파일을 처리하는 함수를 사용하여 디스크 파일에 저장하고 로드할 수 있습니다 .savetxtloadsavesavez

.npy 및 .npz 파일은 ndarray를 재구성하는 데 필요한 데이터, 모양, dtype 및 기타 정보를 저장하여 파일이 아키텍처가 다른 다른 시스템에 있는 경우에도 배열을 올바르게 검색할 수 있도록 합니다 .

단일 ndarray 객체를 저장하려면 .npy 파일로 저장하세요 np.save. 단일 파일에 둘 이상의 ndarray 객체를 저장하려면 .npz 파일로 저장하세요 np.savez. . savez_compressed_

. np.save()_ 저장하려는 어레이와 파일 이름을 지정했는지 확인하십시오. 예를 들어, 다음 어레이를 생성하는 경우:

a = np.array([1, 2, 3, 4, 5, 6])
다음을 사용하여 "filename.npy"로 저장할 수 있습니다.

np.save('filename', a)
np.load()배열을 재구성하는 데 사용할 수 있습니다 .

b = np.load('filename.npy')
어레이를 확인하려면 다음을 실행할 수 있습니다.

print(b)
[1 2 3 4 5 6]
NumPy 배열을 .csv 또는 .txt 파일과 같은 일반 텍스트 파일로 저장할 수 있습니다 np.savetxt.

예를 들어, 다음 어레이를 생성하는 경우:

csv_arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
다음과 같이 "new_file.csv"라는 이름의 .csv 파일로 쉽게 저장할 수 있습니다.

np.savetxt('new_file.csv', csv_arr)
다음을 사용하여 저장된 텍스트 파일을 빠르고 쉽게 로드할 수 있습니다 loadtxt().

np.loadtxt('new_file.csv')
array([1., 2., 3., 4., 5., 6., 7., 8.])
savetxt()및 함수 loadtxt()는 머리글, 바닥글 및 구분 기호와 같은 추가 선택적 매개 변수를 허용합니다. 텍스트 파일은 공유하기 쉬울 수 있지만 .npy 및 .npz 파일은 더 작고 읽기 쉽습니다. 텍스트 파일을 좀 더 정교하게 처리해야 하는 경우(예: 누락된 값이 포함된 줄로 작업해야 하는 경우) 이 함수를 사용하고 싶을 것입니다 genfromtxt .

를 사용하여 savetxt머리글, 바닥글, 주석 등을 지정할 수 있습니다.

여기에서 입력 및 출력 루틴 에 대해 자세히 알아보십시오 .

CSV 가져오기 및 내보내기 
기존 정보가 포함된 CSV에서 읽는 것은 간단합니다. 이를 수행하는 가장 쉽고 쉬운 방법은 Pandas를 사용하는 것입니다 .

import pandas as pd

# If all of your columns are the same type:
x = pd.read_csv('music.csv', header=0).values
print(x)
[['Billie Holiday' 'Jazz' 1300000 27000000]
 ['Jimmie Hendrix' 'Rock' 2700000 70000000]
 ['Miles Davis' 'Jazz' 1500000 48000000]
 ['SIA' 'Pop' 2000000 74000000]]

# You can also simply select the columns you need:
x = pd.read_csv('music.csv', usecols=['Artist', 'Plays']).values
print(x)
[['Billie Holiday' 27000000]
 ['Jimmie Hendrix' 70000000]
 ['Miles Davis' 48000000]
 ['SIA' 74000000]]
../_images/np_pandas.png
배열을 내보내기 위해 Pandas를 사용하는 것도 간단합니다. NumPy를 처음 사용하는 경우 배열의 값에서 Pandas 데이터 프레임을 만든 다음 데이터 프레임을 Pandas를 사용하여 CSV 파일에 쓸 수 있습니다.

이 어레이 "a"를 생성한 경우

a = np.array([[-2.58289208,  0.43014843, -1.24082018, 1.59572603],
              [ 0.99027828, 1.17150989,  0.94125714, -0.14692469],
              [ 0.76989341,  0.81299683, -0.95068423, 0.11769564],
              [ 0.20484034,  0.34784527,  1.96979195, 0.51992837]])
Pandas 데이터 프레임을 만들 수 있습니다.

df = pd.DataFrame(a)
print(df)
          0         1         2         3
0 -2.582892  0.430148 -1.240820  1.595726
1  0.990278  1.171510  0.941257 -0.146925
2  0.769893  0.812997 -0.950684  0.117696
3  0.204840  0.347845  1.969792  0.519928
다음을 사용하여 데이터 프레임을 쉽게 저장할 수 있습니다.

df.to_csv('pd.csv')
다음을 사용하여 CSV를 읽습니다.

data = pd.read_csv('pd.csv')
../_images/np_readcsv.png
NumPy 방법으로 어레이를 저장할 수도 있습니다 savetxt.

np.savetxt('np.csv', a, fmt='%.2f', delimiter=',', header='1,  2,  3,  4')
명령줄을 사용하는 경우 다음과 같은 명령을 사용하여 언제든지 저장된 CSV를 읽을 수 있습니다.

$ cat np.csv
#  1,  2,  3,  4
-2.58,0.43,-1.24,1.60
0.99,1.17,0.94,-0.15
0.77,0.81,-0.95,0.12
0.20,0.35,1.97,0.52
또는 텍스트 편집기로 언제든지 파일을 열 수 있습니다!

Pandas에 대해 자세히 알아보려면 공식 Pandas 문서를 살펴보세요 . 공식 Pandas 설치 정보 로 Pandas를 설치하는 방법을 알아보세요 .

Matplotlib로 배열 그리기 
값에 대한 플롯을 생성해야 하는 경우 Matplotlib를 사용하면 매우 간단합니다 .

예를 들어 다음과 같은 배열이 있을 수 있습니다.

a = np.array([2, 1, 5, 7, 4, 6, 8, 14, 10, 9, 18, 20, 22])
Matplotlib가 이미 설치되어 있는 경우 다음을 사용하여 가져올 수 있습니다.

import matplotlib.pyplot as plt

# If you're using Jupyter Notebook, you may also want to run the following
# line of code to display your code in the notebook:

%matplotlib inline
값을 그리기 위해 해야 할 일은 다음과 같습니다.

plt.plot(a)

# If you are running from a command line, you may need to do this:
# >>> plt.show()
../_images/matplotlib1.png
예를 들어 다음과 같이 1D 배열을 그릴 수 있습니다.

x = np.linspace(0, 5, 20)
y = np.linspace(0, 10, 20)
plt.plot(x, y, 'purple') # line
plt.plot(x, y, 'o')      # dots
../_images/matplotlib2.png
Matplotlib를 사용하면 수많은 시각화 옵션에 액세스할 수 있습니다.

fig = plt.figure()
ax = fig.add_subplot(projection='3d')
X = np.arange(-5, 5, 0.15)
Y = np.arange(-5, 5, 0.15)
X, Y = np.meshgrid(X, Y)
R = np.sqrt(X**2 + Y**2)
Z = np.sin(R)

ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='viridis')
../_images/matplotlib3.png
Matplotlib 및 Matplotlib로 수행할 수 있는 작업에 대한 자세한 내용은 공식 문서를 참조하세요 . Matplotlib 설치에 대한 지침은 공식 설치 섹션을 참조하십시오 .