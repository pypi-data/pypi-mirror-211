# coding=utf-8
# *** WARNING: this file was generated by pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AzureStorageInfoValueResponse',
    'BackupItemResponse',
    'BackupScheduleResponse',
    'ConnStringValueTypePairResponse',
    'DatabaseBackupSettingResponse',
    'IdentifierResponse',
    'NameValuePairResponse',
    'NetworkAccessControlEntryResponse',
    'StampCapacityResponse',
    'StaticSiteUserARMResourceResponse',
    'VirtualIPMappingResponse',
    'VirtualNetworkProfileResponse',
    'WorkerPoolResponse',
]

@pulumi.output_type
class AzureStorageInfoValueResponse(dict):
    """
    Azure Files or Blob Storage access information value for dictionary storage.
    """
    def __init__(__self__, *,
                 state: str,
                 access_key: Optional[str] = None,
                 account_name: Optional[str] = None,
                 mount_path: Optional[str] = None,
                 share_name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Azure Files or Blob Storage access information value for dictionary storage.
        :param str state: State of the storage account.
        :param str access_key: Access key for the storage account.
        :param str account_name: Name of the storage account.
        :param str mount_path: Path to mount the storage within the site's runtime environment.
        :param str share_name: Name of the file share (container name, for Blob storage).
        :param str type: Type of storage.
        """
        pulumi.set(__self__, "state", state)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of the storage account.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[str]:
        """
        Name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        Path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[str]:
        """
        Name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of storage.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BackupItemResponse(dict):
    """
    Backup description.
    """
    def __init__(__self__, *,
                 backup_id: int,
                 blob_name: str,
                 correlation_id: str,
                 created: str,
                 databases: Sequence['outputs.DatabaseBackupSettingResponse'],
                 finished_time_stamp: str,
                 id: str,
                 last_restore_time_stamp: str,
                 log: str,
                 name: str,
                 scheduled: bool,
                 size_in_bytes: float,
                 status: str,
                 storage_account_url: str,
                 type: str,
                 website_size_in_bytes: float,
                 kind: Optional[str] = None):
        """
        Backup description.
        :param int backup_id: Id of the backup.
        :param str blob_name: Name of the blob which contains data for this backup.
        :param str correlation_id: Unique correlation identifier. Please use this along with the timestamp while communicating with Azure support.
        :param str created: Timestamp of the backup creation.
        :param Sequence['DatabaseBackupSettingResponse'] databases: List of databases included in the backup.
        :param str finished_time_stamp: Timestamp when this backup finished.
        :param str id: Resource Id.
        :param str last_restore_time_stamp: Timestamp of a last restore operation which used this backup.
        :param str log: Details regarding this backup. Might contain an error message.
        :param str name: Resource Name.
        :param bool scheduled: True if this backup has been created due to a schedule being triggered.
        :param float size_in_bytes: Size of the backup in bytes.
        :param str status: Backup status.
        :param str storage_account_url: SAS URL for the storage account container which contains this backup.
        :param str type: Resource type.
        :param float website_size_in_bytes: Size of the original web app which has been backed up.
        :param str kind: Kind of resource.
        """
        pulumi.set(__self__, "backup_id", backup_id)
        pulumi.set(__self__, "blob_name", blob_name)
        pulumi.set(__self__, "correlation_id", correlation_id)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "finished_time_stamp", finished_time_stamp)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_restore_time_stamp", last_restore_time_stamp)
        pulumi.set(__self__, "log", log)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scheduled", scheduled)
        pulumi.set(__self__, "size_in_bytes", size_in_bytes)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "website_size_in_bytes", website_size_in_bytes)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> int:
        """
        Id of the backup.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="blobName")
    def blob_name(self) -> str:
        """
        Name of the blob which contains data for this backup.
        """
        return pulumi.get(self, "blob_name")

    @property
    @pulumi.getter(name="correlationId")
    def correlation_id(self) -> str:
        """
        Unique correlation identifier. Please use this along with the timestamp while communicating with Azure support.
        """
        return pulumi.get(self, "correlation_id")

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        Timestamp of the backup creation.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.DatabaseBackupSettingResponse']:
        """
        List of databases included in the backup.
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="finishedTimeStamp")
    def finished_time_stamp(self) -> str:
        """
        Timestamp when this backup finished.
        """
        return pulumi.get(self, "finished_time_stamp")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastRestoreTimeStamp")
    def last_restore_time_stamp(self) -> str:
        """
        Timestamp of a last restore operation which used this backup.
        """
        return pulumi.get(self, "last_restore_time_stamp")

    @property
    @pulumi.getter
    def log(self) -> str:
        """
        Details regarding this backup. Might contain an error message.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scheduled(self) -> bool:
        """
        True if this backup has been created due to a schedule being triggered.
        """
        return pulumi.get(self, "scheduled")

    @property
    @pulumi.getter(name="sizeInBytes")
    def size_in_bytes(self) -> float:
        """
        Size of the backup in bytes.
        """
        return pulumi.get(self, "size_in_bytes")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Backup status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> str:
        """
        SAS URL for the storage account container which contains this backup.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="websiteSizeInBytes")
    def website_size_in_bytes(self) -> float:
        """
        Size of the original web app which has been backed up.
        """
        return pulumi.get(self, "website_size_in_bytes")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class BackupScheduleResponse(dict):
    """
    Description of a backup schedule. Describes how often should be the backup performed and what should be the retention policy.
    """
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_unit: str,
                 keep_at_least_one_backup: bool,
                 last_execution_time: str,
                 retention_period_in_days: int,
                 start_time: Optional[str] = None):
        """
        Description of a backup schedule. Describes how often should be the backup performed and what should be the retention policy.
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        :param str frequency_unit: The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        :param bool keep_at_least_one_backup: True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        :param str last_execution_time: Last time when this schedule was triggered.
        :param int retention_period_in_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start working.
        """
        if frequency_interval is None:
            frequency_interval = 7
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_unit is None:
            frequency_unit = 'Day'
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is None:
            keep_at_least_one_backup = True
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_in_days is None:
            retention_period_in_days = 30
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> str:
        """
        The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> bool:
        """
        True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> str:
        """
        Last time when this schedule was triggered.
        """
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> int:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_in_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ConnStringValueTypePairResponse(dict):
    """
    Database connection string value to type pair.
    """
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        Database connection string value to type pair.
        :param str type: Type of database.
        :param str value: Value of pair.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of database.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of pair.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DatabaseBackupSettingResponse(dict):
    """
    Database backup settings.
    """
    def __init__(__self__, *,
                 database_type: str,
                 connection_string: Optional[str] = None,
                 connection_string_name: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Database backup settings.
        :param str database_type: Database type (e.g. SqlAzure / MySql).
        :param str connection_string: Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        :param str connection_string_name: Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
               This is used during restore with overwrite connection strings options.
        """
        pulumi.set(__self__, "database_type", database_type)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if connection_string_name is not None:
            pulumi.set(__self__, "connection_string_name", connection_string_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> str:
        """
        Database type (e.g. SqlAzure / MySql).
        """
        return pulumi.get(self, "database_type")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        """
        Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="connectionStringName")
    def connection_string_name(self) -> Optional[str]:
        """
        Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
        This is used during restore with overwrite connection strings options.
        """
        return pulumi.get(self, "connection_string_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class IdentifierResponse(dict):
    """
    A domain specific resource identifier.
    """
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str,
                 kind: Optional[str] = None,
                 value: Optional[str] = None):
        """
        A domain specific resource identifier.
        :param str id: Resource Id.
        :param str name: Resource Name.
        :param str type: Resource type.
        :param str kind: Kind of resource.
        :param str value: String representation of the identity.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        String representation of the identity.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NameValuePairResponse(dict):
    """
    Name value pair.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Name value pair.
        :param str name: Pair name.
        :param str value: Pair value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Pair name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Pair value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkAccessControlEntryResponse(dict):
    """
    Network access control entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteSubnet":
            suggest = "remote_subnet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAccessControlEntryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAccessControlEntryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAccessControlEntryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 description: Optional[str] = None,
                 order: Optional[int] = None,
                 remote_subnet: Optional[str] = None):
        """
        Network access control entry.
        :param str action: Action object.
        :param str description: Description of network access control entry.
        :param int order: Order of precedence.
        :param str remote_subnet: Remote subnet.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if remote_subnet is not None:
            pulumi.set(__self__, "remote_subnet", remote_subnet)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action object.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of network access control entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Order of precedence.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="remoteSubnet")
    def remote_subnet(self) -> Optional[str]:
        """
        Remote subnet.
        """
        return pulumi.get(self, "remote_subnet")


@pulumi.output_type
class StampCapacityResponse(dict):
    """
    Stamp capacity information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableCapacity":
            suggest = "available_capacity"
        elif key == "computeMode":
            suggest = "compute_mode"
        elif key == "excludeFromCapacityAllocation":
            suggest = "exclude_from_capacity_allocation"
        elif key == "isApplicableForAllComputeModes":
            suggest = "is_applicable_for_all_compute_modes"
        elif key == "isLinux":
            suggest = "is_linux"
        elif key == "siteMode":
            suggest = "site_mode"
        elif key == "totalCapacity":
            suggest = "total_capacity"
        elif key == "workerSize":
            suggest = "worker_size"
        elif key == "workerSizeId":
            suggest = "worker_size_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StampCapacityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StampCapacityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StampCapacityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_capacity: Optional[float] = None,
                 compute_mode: Optional[str] = None,
                 exclude_from_capacity_allocation: Optional[bool] = None,
                 is_applicable_for_all_compute_modes: Optional[bool] = None,
                 is_linux: Optional[bool] = None,
                 name: Optional[str] = None,
                 site_mode: Optional[str] = None,
                 total_capacity: Optional[float] = None,
                 unit: Optional[str] = None,
                 worker_size: Optional[str] = None,
                 worker_size_id: Optional[int] = None):
        """
        Stamp capacity information.
        :param float available_capacity: Available capacity (# of machines, bytes of storage etc...).
        :param str compute_mode: Shared/dedicated workers.
        :param bool exclude_from_capacity_allocation: If <code>true</code>, it includes basic apps.
               Basic apps are not used for capacity allocation.
        :param bool is_applicable_for_all_compute_modes: <code>true</code> if capacity is applicable for all apps; otherwise, <code>false</code>.
        :param bool is_linux: Is this a linux stamp capacity
        :param str name: Name of the stamp.
        :param str site_mode: Shared or Dedicated.
        :param float total_capacity: Total capacity (# of machines, bytes of storage etc...).
        :param str unit: Name of the unit.
        :param str worker_size: Size of the machines.
        :param int worker_size_id: Size ID of machines: 
               0 - Small
               1 - Medium
               2 - Large
        """
        if available_capacity is not None:
            pulumi.set(__self__, "available_capacity", available_capacity)
        if compute_mode is not None:
            pulumi.set(__self__, "compute_mode", compute_mode)
        if exclude_from_capacity_allocation is not None:
            pulumi.set(__self__, "exclude_from_capacity_allocation", exclude_from_capacity_allocation)
        if is_applicable_for_all_compute_modes is not None:
            pulumi.set(__self__, "is_applicable_for_all_compute_modes", is_applicable_for_all_compute_modes)
        if is_linux is not None:
            pulumi.set(__self__, "is_linux", is_linux)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if site_mode is not None:
            pulumi.set(__self__, "site_mode", site_mode)
        if total_capacity is not None:
            pulumi.set(__self__, "total_capacity", total_capacity)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if worker_size is not None:
            pulumi.set(__self__, "worker_size", worker_size)
        if worker_size_id is not None:
            pulumi.set(__self__, "worker_size_id", worker_size_id)

    @property
    @pulumi.getter(name="availableCapacity")
    def available_capacity(self) -> Optional[float]:
        """
        Available capacity (# of machines, bytes of storage etc...).
        """
        return pulumi.get(self, "available_capacity")

    @property
    @pulumi.getter(name="computeMode")
    def compute_mode(self) -> Optional[str]:
        """
        Shared/dedicated workers.
        """
        return pulumi.get(self, "compute_mode")

    @property
    @pulumi.getter(name="excludeFromCapacityAllocation")
    def exclude_from_capacity_allocation(self) -> Optional[bool]:
        """
        If <code>true</code>, it includes basic apps.
        Basic apps are not used for capacity allocation.
        """
        return pulumi.get(self, "exclude_from_capacity_allocation")

    @property
    @pulumi.getter(name="isApplicableForAllComputeModes")
    def is_applicable_for_all_compute_modes(self) -> Optional[bool]:
        """
        <code>true</code> if capacity is applicable for all apps; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "is_applicable_for_all_compute_modes")

    @property
    @pulumi.getter(name="isLinux")
    def is_linux(self) -> Optional[bool]:
        """
        Is this a linux stamp capacity
        """
        return pulumi.get(self, "is_linux")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the stamp.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="siteMode")
    def site_mode(self) -> Optional[str]:
        """
        Shared or Dedicated.
        """
        return pulumi.get(self, "site_mode")

    @property
    @pulumi.getter(name="totalCapacity")
    def total_capacity(self) -> Optional[float]:
        """
        Total capacity (# of machines, bytes of storage etc...).
        """
        return pulumi.get(self, "total_capacity")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        Name of the unit.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="workerSize")
    def worker_size(self) -> Optional[str]:
        """
        Size of the machines.
        """
        return pulumi.get(self, "worker_size")

    @property
    @pulumi.getter(name="workerSizeId")
    def worker_size_id(self) -> Optional[int]:
        """
        Size ID of machines: 
        0 - Small
        1 - Medium
        2 - Large
        """
        return pulumi.get(self, "worker_size_id")


@pulumi.output_type
class StaticSiteUserARMResourceResponse(dict):
    """
    Static Site User ARM resource.
    """
    def __init__(__self__, *,
                 display_name: str,
                 id: str,
                 name: str,
                 provider: str,
                 type: str,
                 user_id: str,
                 kind: Optional[str] = None,
                 roles: Optional[str] = None):
        """
        Static Site User ARM resource.
        :param str display_name: The display name for the static site user.
        :param str id: Resource Id.
        :param str name: Resource Name.
        :param str provider: The identity provider for the static site user.
        :param str type: Resource type.
        :param str user_id: The user id for the static site user.
        :param str kind: Kind of resource.
        :param str roles: The roles for the static site user, in free-form string format
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_id", user_id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name for the static site user.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        The identity provider for the static site user.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        The user id for the static site user.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def roles(self) -> Optional[str]:
        """
        The roles for the static site user, in free-form string format
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class VirtualIPMappingResponse(dict):
    """
    Virtual IP mapping.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inUse":
            suggest = "in_use"
        elif key == "internalHttpPort":
            suggest = "internal_http_port"
        elif key == "internalHttpsPort":
            suggest = "internal_https_port"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "virtualIP":
            suggest = "virtual_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualIPMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualIPMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualIPMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_use: Optional[bool] = None,
                 internal_http_port: Optional[int] = None,
                 internal_https_port: Optional[int] = None,
                 service_name: Optional[str] = None,
                 virtual_ip: Optional[str] = None):
        """
        Virtual IP mapping.
        :param bool in_use: Is virtual IP mapping in use.
        :param int internal_http_port: Internal HTTP port.
        :param int internal_https_port: Internal HTTPS port.
        :param str service_name: name of the service that virtual IP is assigned to
        :param str virtual_ip: Virtual IP address.
        """
        if in_use is not None:
            pulumi.set(__self__, "in_use", in_use)
        if internal_http_port is not None:
            pulumi.set(__self__, "internal_http_port", internal_http_port)
        if internal_https_port is not None:
            pulumi.set(__self__, "internal_https_port", internal_https_port)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if virtual_ip is not None:
            pulumi.set(__self__, "virtual_ip", virtual_ip)

    @property
    @pulumi.getter(name="inUse")
    def in_use(self) -> Optional[bool]:
        """
        Is virtual IP mapping in use.
        """
        return pulumi.get(self, "in_use")

    @property
    @pulumi.getter(name="internalHttpPort")
    def internal_http_port(self) -> Optional[int]:
        """
        Internal HTTP port.
        """
        return pulumi.get(self, "internal_http_port")

    @property
    @pulumi.getter(name="internalHttpsPort")
    def internal_https_port(self) -> Optional[int]:
        """
        Internal HTTPS port.
        """
        return pulumi.get(self, "internal_https_port")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        name of the service that virtual IP is assigned to
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="virtualIP")
    def virtual_ip(self) -> Optional[str]:
        """
        Virtual IP address.
        """
        return pulumi.get(self, "virtual_ip")


@pulumi.output_type
class VirtualNetworkProfileResponse(dict):
    """
    Specification for using a Virtual Network.
    """
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 id: Optional[str] = None,
                 subnet: Optional[str] = None):
        """
        Specification for using a Virtual Network.
        :param str name: Name of the Virtual Network (read-only).
        :param str type: Resource type of the Virtual Network (read-only).
        :param str id: Resource id of the Virtual Network.
        :param str subnet: Subnet within the Virtual Network.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Virtual Network (read-only).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type of the Virtual Network (read-only).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource id of the Virtual Network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[str]:
        """
        Subnet within the Virtual Network.
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class WorkerPoolResponse(dict):
    """
    Worker pool of an App Service Environment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNames":
            suggest = "instance_names"
        elif key == "computeMode":
            suggest = "compute_mode"
        elif key == "workerCount":
            suggest = "worker_count"
        elif key == "workerSize":
            suggest = "worker_size"
        elif key == "workerSizeId":
            suggest = "worker_size_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkerPoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkerPoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkerPoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_names: Sequence[str],
                 compute_mode: Optional[str] = None,
                 worker_count: Optional[int] = None,
                 worker_size: Optional[str] = None,
                 worker_size_id: Optional[int] = None):
        """
        Worker pool of an App Service Environment.
        :param Sequence[str] instance_names: Names of all instances in the worker pool (read only).
        :param str compute_mode: Shared or dedicated app hosting.
        :param int worker_count: Number of instances in the worker pool.
        :param str worker_size: VM size of the worker pool instances.
        :param int worker_size_id: Worker size ID for referencing this worker pool.
        """
        pulumi.set(__self__, "instance_names", instance_names)
        if compute_mode is not None:
            pulumi.set(__self__, "compute_mode", compute_mode)
        if worker_count is not None:
            pulumi.set(__self__, "worker_count", worker_count)
        if worker_size is not None:
            pulumi.set(__self__, "worker_size", worker_size)
        if worker_size_id is not None:
            pulumi.set(__self__, "worker_size_id", worker_size_id)

    @property
    @pulumi.getter(name="instanceNames")
    def instance_names(self) -> Sequence[str]:
        """
        Names of all instances in the worker pool (read only).
        """
        return pulumi.get(self, "instance_names")

    @property
    @pulumi.getter(name="computeMode")
    def compute_mode(self) -> Optional[str]:
        """
        Shared or dedicated app hosting.
        """
        return pulumi.get(self, "compute_mode")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        Number of instances in the worker pool.
        """
        return pulumi.get(self, "worker_count")

    @property
    @pulumi.getter(name="workerSize")
    def worker_size(self) -> Optional[str]:
        """
        VM size of the worker pool instances.
        """
        return pulumi.get(self, "worker_size")

    @property
    @pulumi.getter(name="workerSizeId")
    def worker_size_id(self) -> Optional[int]:
        """
        Worker size ID for referencing this worker pool.
        """
        return pulumi.get(self, "worker_size_id")


