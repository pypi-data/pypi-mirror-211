import{g as st}from"./_commonjsHelpers.725317a4.js";import{d as W,l as rt,c as ot}from"./2.cb8e4807.js";let m=63710088e-1,lt={centimeters:m*100,centimetres:m*100,degrees:180/Math.PI,feet:m*3.28084,inches:m*39.37,kilometers:m/1e3,kilometres:m/1e3,meters:m,metres:m,miles:m/1609.344,millimeters:m*1e3,millimetres:m*1e3,nauticalmiles:m/1852,radians:1,yards:m/1.0936};function T(i,t,e){e=S(e);const n={type:"Feature"};return(e.id===0||e.id)&&(n.id=e.id),e.bbox&&(n.bbox=e.bbox),n.properties=t||{},n.geometry=i,n}function ht(i,t,e){return e=S(e),T({type:"Point",coordinates:i},t,e)}function ct(i,t,e){e=S(e);for(const s of i){if(s.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(let r=0;r<s[s.length-1].length;r++)if(s[s.length-1][r]!==s[0][r])throw new Error("First and last Position are not equivalent.")}return T({type:"Polygon",coordinates:i},t,e)}function K(i,t,e){return e=S(e),T({type:"MultiPolygon",coordinates:i},t,e)}function ut(i,t){if(i==null)throw new Error("distance is required");if(t&&typeof t!="string")throw new Error("units must be a string");var e=lt[t||"kilometers"];if(!e)throw new Error(t+" units is invalid");return i/e}function j(i){if(i==null)throw new Error("radians is required");return i%(2*Math.PI)*180/Math.PI}function C(i){if(i==null)throw new Error("degrees is required");return i%360*Math.PI/180}function at(i){return!!i&&i.constructor===Object}function S(i){if(i=i||{},!at(i))throw new Error("options is invalid");return i}function ft(i){if(!i)throw new Error("coord is required");if(!Array.isArray(i)){if(i.type==="Feature"&&i.geometry!==null&&i.geometry.type==="Point")return i.geometry.coordinates;if(i.type==="Point")return i.coordinates}if(Array.isArray(i)&&i.length>=2&&!Array.isArray(i[0])&&!Array.isArray(i[1]))return i;throw new Error("coord must be GeoJSON Point or an Array of numbers")}function V(i){return i.type==="Feature"?i.geometry:i}function pt(i,t,e,n){n=S(n);const s=ft(i),r=C(s[0]),o=C(s[1]),l=C(e),u=ut(t,n.units),h=Math.asin(Math.sin(o)*Math.cos(u)+Math.cos(o)*Math.sin(u)*Math.cos(l)),c=r+Math.atan2(Math.sin(l)*Math.sin(u)*Math.cos(o),Math.cos(u)-Math.sin(o)*Math.sin(h)),a=j(c),f=j(h);return ht([a,f],n.properties)}function gt(i,t,e){e=S(e);const n=e.steps||64,s=e.properties?e.properties:!Array.isArray(i)&&i.type==="Feature"&&i.properties?i.properties:{},r=[];for(let o=0;o<n;o++)r.push(pt(i,t,o*-360/n,e).geometry.coordinates);return r.push(r[0]),ct([r],s)}var dt=p;function yt(i,t){return i<t}function p(i){i=i||{},typeof i=="function"&&(i={compar:i}),i.compar?this._isBefore=function(t,e){return i.compar(t,e)<0}:i.comparBefore?this._isBefore=i.comparBefore:this._isBefore=yt,this.length=0,this._freeSpace=i.freeSpace?this._trimArraySize:!1,this._list=new Array(i.size||100)}p.prototype._list=null;p.prototype._compar=null;p.prototype._isBefore=null;p.prototype._freeSpace=null;p.prototype.length=0;p.prototype.insert=function(t){var e=++this.length,n=this._list;for(n[e]=t;e>1;){var s=e>>1,r=n[s];if(!this._isBefore(t,r))break;n[e]=r,e=s}n[e]=t};p.prototype.append=p.prototype.insert;p.prototype.push=p.prototype.insert;p.prototype.unshift=p.prototype.insert;p.prototype.enqueue=p.prototype.insert;p.prototype.peek=function(){return this.length>0?this._list[1]:void 0};p.prototype.size=function(){return this.length};p.prototype.remove=function(){if(!(this.length<1)){for(var t=this._list[1],e=this._list[this.length],n=1,s=2,r,o=this.length;s<o&&(r=this._list[s],this._isBefore(this._list[s+1],r)&&(r=this._list[s+1],s=s+1),!!this._isBefore(r,e));)this._list[n]=r,n=s,s=s<<1;return this._list[o]=0,this.length=--o,o&&(this._list[n]=e),this._freeSpace&&this._freeSpace(this._list,o),t}};p.prototype.shift=p.prototype.remove;p.prototype.pop=p.prototype.remove;p.prototype.dequeue=p.prototype.remove;p.prototype.gc=function(t){t||(t={});var e=t.minLength;e===void 0&&(e=0);var n=t.minFull;n===void 0&&(n=1),this._list.length>=e&&this.length<this._list.length*n&&this._list.splice(this.length+1,this._list.length)};p.prototype._trimArraySize=function(t,e){e>1e4&&t.length>4*e&&t.splice(e+1,t.length)};p.prototype._check=function(){var t=this._isBefore,e=function(o,l){return t(o,l)?-1:1},n,s,r=0;for(n=this.length;n>1;n--)s=n>>>1,e(this._list[s],this._list[n])>0&&e(this._list[n],this._list[s])<0&&(r=n);return r&&console.log("failed at",r>>>1,r),!r};p.prototype=p.prototype;var _t=dt;const mt=st(_t);Number.EPSILON===void 0&&(Number.EPSILON=Math.pow(2,-52));const U=Number.EPSILON*Number.EPSILON,g=(i,t)=>-Number.EPSILON<i&&i<Number.EPSILON&&-Number.EPSILON<t&&t<Number.EPSILON||(i-t)*(i-t)<U*i*t?0:i<t?-1:1,v=(i,t)=>{let e=i.x,n=t.x;if(e<=-Number.EPSILON||Number.EPSILON<=e||n<=-Number.EPSILON||Number.EPSILON<=n){const s=e-n;if(s*s>=U*e*n)return e<n?-1:1}if(e=i.y,n=t.y,e<=-Number.EPSILON||Number.EPSILON<=e||n<=-Number.EPSILON||Number.EPSILON<=n){const s=e-n;if(s*s>=U*e*n)return e<n?-1:1}return 0},I=(i,t)=>i.x*t.y-i.y*t.x,tt=(i,t)=>i.x*t.x+i.y*t.y,k=(i,t,e)=>{const n={x:t.x-i.x,y:t.y-i.y},s={x:e.x-i.x,y:e.y-i.y},r=I(n,s);return g(r,0)},O=i=>Math.sqrt(tt(i,i)),Et=(i,t,e)=>{const n={x:t.x-i.x,y:t.y-i.y},s={x:e.x-i.x,y:e.y-i.y};return I(s,n)/O(s)/O(n)},xt=(i,t,e)=>{const n={x:t.x-i.x,y:t.y-i.y},s={x:e.x-i.x,y:e.y-i.y};return tt(s,n)/O(s)/O(n)},H=i=>{const t=[];if(!Array.isArray(i))throw new Error("Input is not a Polygon or MultiPolygon");for(let e=0,n=i.length;e<n;e++){if(!Array.isArray(i[e]))throw new Error("Input is not a Polygon or MultiPolygon");t.push([]);for(let s=0,r=i[e].length;s<r;s++){if(!Array.isArray(i[e][s]))throw new Error("Input is not a Polygon or MultiPolygon");if(i[e][s].length===2){t[e].push({x:i[e][s][0],y:i[e][s][1]});continue}t[e].push([]);for(let o=0,l=i[e][s].length;o<l;o++){if(!Array.isArray(i[e][s][o])||i[e][s][o].length!==2)throw new Error("Input is not a Polygon or MultiPolygon");t[e][s].push({x:i[e][s][o][0],y:i[e][s][o][1]})}}}return t},vt=i=>{if(Array.isArray(i)){if(i.length===0)return;if(Array.isArray(i[0])){if(Array.isArray(i[0][0])&&typeof i[0][0][0].x=="number"&&typeof i[0][0][0].y=="number")return;if(typeof i[0][0].x=="number"&&typeof i[0][0].y=="number"){i.unshift(i.splice(0));return}}}throw new Error("Unrecognized input - not a polygon nor multipolygon")},wt=i=>{let t=0;for(;t<i.length;){const e=i[t];if(e.length===0){i.splice(t,1);continue}const n=e[0];if(J(n),n.length===0){i.splice(t,1);continue}let s=1;for(;s<e.length;){const r=e[s];J(r),r.length===0?e.splice(s,1):s++}t++}},J=i=>{if(i.length===0)return;v(i[0],i[i.length-1])!==0&&i.push({x:i[0].x,y:i[0].y});const t=(n,s,r)=>v(n,s)===0||v(s,r)===0||k(s,n,r)===0;let e=1;for(;e<i.length-1;)t(i[e-1],i[e],i[e+1])?i.splice(e,1):e++;for(;i.length>2&&t(i[i.length-2],i[0],i[1]);)i.splice(0,1),i.splice(i.length-1,1),i.push(i[0]);for(;i.length<4&&i.length>0;)i.pop()},St=i=>{for(let t=0,e=i.length;t<e;t++){const n=i[t],s=n.flowIntoSE;if(s.linkedEvents.length>2){const r=s.linkedEvents.filter(o=>o.segment.ringIn===n.ringIn);if(r.length>2){r.sort(s.getLeftmostComparator(s.otherSE));const o=r[1],l=r[r.length-1];if(o.segment.flowIntoSE===o||l.segment.flowIntoSE===l)throw new Error(`Self-intersecting, crossing input ring found at [${s.point.x}, ${s.point.y}]`)}}}};class Mt{constructor(){this.types={INTERSECTION:0,UNION:1,XOR:2,DIFFERENCE:3}}register(t,e){this.type=t,this.numMultiPolys=e}}const x=new Mt;class P{static compareBefore(t,e){const n=g(t.point.x,e.point.x);if(n!==0)return n<0;const s=g(t.point.y,e.point.y);if(s!==0)return s<0;if(t.isLeft!==e.isLeft)return!t.isLeft;const r=t.segment.comparePoint(e.otherSE.point);if(r!==0)return r>0;const o=t.segment.ringIn.id,l=e.segment.ringIn.id;if(o!==l)return o<l;if(t===e)return!1;throw new Error(`SweepEvent comparison failed at [${t.point.x}, ${t.point.y}]... equal but not identical?`)}constructor(t,e){this.point=t,this.segment=e,this.linkedEvents=[this]}link(t){const e=t.linkedEvents;for(let n=0,s=e.length;n<s;n++){const r=e[n];this.linkedEvents.push(r),r.linkedEvents=this.linkedEvents}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.linkedEvents.length;e<n;e++){const s=this.linkedEvents[e];s!==this&&!s.segment.ringOut&&s.segment.isInResult&&t.push(s)}return t}getLeftmostComparator(t){const e=new Map,n=s=>{const r=s.otherSE;e.set(s,{sine:Et(this.point,t.point,r.point),cosine:xt(this.point,t.point,r.point)})};return(s,r)=>{e.has(s)||n(s),e.has(r)||n(r);const{sine:o,cosine:l}=e.get(s),{sine:u,cosine:h}=e.get(r),c=g(o,0),a=g(u,0);return c>=0&&a>=0?g(h,l):c<0&&a<0?g(l,h):g(u,o)}}get isLeft(){return this===this.segment.leftSE}get isRight(){return this===this.segment.rightSE}get otherSE(){return this.segment.getOtherSE(this)}}const Lt=(i,t)=>{const e=i.ll.x,n=i.ll.y,s=i.ur.x,r=i.ur.y,o=t.x,l=t.y;return g(e,o)<=0&&g(o,s)<=0&&g(n,l)<=0&&g(l,r)<=0},Pt=(i,t)=>!(g(t.ur.x,i.ll.x)<0||g(i.ur.x,t.ll.x)<0||g(t.ur.y,i.ll.y)<0||g(i.ur.y,t.ll.y)<0),It=(i,t)=>{if(!Pt(i,t))return null;const e=i.ll.x<t.ll.x?t.ll.x:i.ll.x,n=i.ur.x<t.ur.x?i.ur.x:t.ur.x,s=i.ll.y<t.ll.y?t.ll.y:i.ll.y,r=i.ur.y<t.ur.y?i.ur.y:t.ur.y;return{ll:{x:e,y:s},ur:{x:n,y:r}}},Rt=i=>{const t=i.ll.x,e=i.ll.y,n=i.ur.x,s=i.ur.y,r=g(t,n)===0,o=g(e,s)===0;return r&&o?[{x:t,y:e}]:r?[{x:t,y:e},{x:t,y:s}]:o?[{x:t,y:e},{x:n,y:e}]:[{x:t,y:e},{x:t,y:s},{x:n,y:e},{x:n,y:s}]};class N{static compare(t,e){if(t===e)return 0;const n=t.leftSE.point.x,s=t.leftSE.point.y,r=e.leftSE.point.x,o=e.leftSE.point.y,l=t.rightSE.point.x,u=e.rightSE.point.x;if(g(u,n)<0)return 1;if(g(l,r)<0)return-1;const h=t.comparePoint(e.leftSE.point),c=g(n,r);if(h===0&&t.comparePoint(e.rightSE.point)===0&&e.comparePoint(t.leftSE.point)===0&&e.comparePoint(t.rightSE.point)===0){if(c!==0)return c;if(t.ringIn.id!==e.ringIn.id)return t.ringIn.id<e.ringIn.id?-1:1}else return c<0?h===1?-1:1:c>0?e.comparePoint(t.leftSE.point)===1?1:-1:c===0&&g(t.leftSE.point.y,e.leftSE.point.y)===0?t.comparePoint(e.rightSE.point)>0?-1:1:g(s,o);throw new Error(`Segment comparison (from [${t.leftSE.point.x}, ${t.leftSR.point.y}]) -> to [${t.rightSE.point.x}, ${t.rightSE.point.y}]) failed...  segments equal but not identical?`)}constructor(t,e,n){this.ringIn=n,this.ringOut=null;const s=v(t,e);let r,o;if(s<0)r=t,o=e,this.flowL2R=!0;else if(s>0)r=e,o=t,this.flowL2R=!1;else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);this.leftSE=new P(r,this),this.rightSE=new P(o,this),this._clearCache()}clone(){const t=new N(this.leftSE.point,this.rightSE.point,this.ringIn);return t.flowL2R=this.flowL2R,t}get bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}get vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}get isVertical(){return g(this.leftSE.point.x,this.rightSE.point.x)===0}get flowIntoSE(){return this.flowL2R?this.rightSE:this.leftSE}getOtherSE(t){if(t===this.leftSE)return this.rightSE;if(t===this.rightSE)return this.leftSE;throw new Error("may only be called by own sweep events")}isAnEndpoint(t){return v(t,this.leftSE.point)===0||v(t,this.rightSE.point)===0}isPointOn(t){return Lt(this.bbox,t)&&this.comparePoint(t)===0}comparePoint(t){return this.isAnEndpoint(t)?0:k(t,this.leftSE.point,this.rightSE.point)}getIntersections(t){const e=It(this.bbox,t.bbox);if(e===null)return[];const n=[],s=Rt(e);for(let _=0,E=s.length;_<E;_++){const M=s[_];(this.isAnEndpoint(M)&&t.isPointOn(M)||t.isAnEndpoint(M)&&this.isPointOn(M))&&n.push(M)}if(n.length>0)return n;const r=this.leftSE.point,o=t.leftSE.point,l=this.vector,u=t.vector,h={x:o.x-r.x,y:o.y-r.y},c=I(l,u),a=I(h,u)/c;if(g(a,0)<0||g(1,a)<0)return[];const f=I(h,l)/c;if(g(f,0)<0||g(1,f)<0)return[];let d=(r.x+a*l.x+o.x+f*u.x)/2,y=(r.y+a*l.y+o.y+f*u.y)/2;return d<e.ll.x&&(d=e.ll.x),d>e.ur.x&&(d=e.ur.x),y<e.ll.y&&(y=e.ll.y),y>e.ur.y&&(y=e.ur.y),[{x:d,y}]}split(t){t.sort(v),t=t.filter((r,o,l)=>o===0||v(l[o-1],r)!==0);for(let r=0,o=t.length;r<o;r++){const l=t[r];if(this.isAnEndpoint(l))throw new Error(`Cannot split segment upon endpoint at [${l.x}, ${l.y}]`)}const e=t.shift(),n=this.clone();n.leftSE=new P(e,n),n.rightSE=this.rightSE,this.rightSE.segment=n,this.rightSE=new P(e,this);const s=[this.rightSE,n.leftSE];if(t.length>0){const r=n.split(t);for(let o=0,l=r.length;o<l;o++)s.push(r[o])}return s}registerPrev(t){this.prev=t,this._clearCache()}registerRingOut(t){this.ringOut=t}get prevInResult(){const t="prevInResult";return this._cache[t]===void 0&&(this._cache[t]=this[`_${t}`]()),this._cache[t]}_prevInResult(){let t=this.prev;for(;t&&!t.isInResult;)t=t.prev;return t}get coincidents(){const t="coincidents";return this._cache[t]===void 0&&(this._cache[t]=this[`_${t}`]()),this._cache[t]}_coincidents(){const t=[],e=this.leftSE.linkedEvents,n=this.rightSE.linkedEvents;for(let s=0,r=e.length;s<r;s++){const o=e[s];o.isLeft&&o.segment.rightSE.linkedEvents===n&&t.push(o.segment)}if(t.length>0){t.sort((s,r)=>s.ringIn.id-r.ringIn.id);for(let s=0,r=t.length;s<r;s++)t[s]._cache.coincidents=t}return t}get prevNotCoincident(){const t="prevNotCoincident";return this._cache[t]===void 0&&(this._cache[t]=this[`_${t}`]()),this._cache[t]}_prevNotCoincident(){let t=this,e=this.prev;for(;e&&t.coincidents===e.coincidents;)t=e,e=e.prev;return e}get sweepLineEntersRing(){const t="sweepLineEntersRing";return this._cache[t]===void 0&&(this._cache[t]=this[`_${t}`]()),this._cache[t]}_sweepLineEntersRing(){let t=this.prevNotCoincident;for(;t;){for(let e=0,n=t.coincidents.length;e<n;e++){const s=t.coincidents[e];if(s.ringIn===this.ringIn)return!s.sweepLineEntersRing}t=t.prevNotCoincident}return!0}get sweepLineEntersPoly(){return this.isValidEdgeForPoly?this.ringIn.isExterior===this.sweepLineEntersRing:!1}get sweepLineExitsPoly(){return this.isValidEdgeForPoly?this.ringIn.isExterior!==this.sweepLineEntersRing:!1}get ringsInsideOf(){const t="ringsInsideOf";return this._cache[t]===void 0&&(this._cache[t]=this[`_${t}`]()),this._cache[t]}_ringsInsideOf(){if(!this.prev)return[];if(this.coincidents===this.prev.coincidents)return this.prev.ringsInsideOf;let t=[],e=this.prev.ringsInsideOf,n=this.prev.getRingsEntering(),s=this.getRingsExiting();for(let r=0,o=e.length;r<o;r++){const l=e[r];s.includes(l)||t.push(l)}for(let r=0,o=n.length;r<o;r++){const l=n[r];s.includes(l)||t.push(l)}return t}getRingsOnEdgeOf(){const t=[];for(let e=0,n=this.coincidents.length;e<n;e++)t.push(this.coincidents[e].ringIn);return t}getRingsEntering(){const t=[];for(let e=0,n=this.coincidents.length;e<n;e++){const s=this.coincidents[e];s.sweepLineEntersRing&&t.push(s.ringIn)}return t}getRingsExiting(){const t=[];for(let e=0,n=this.coincidents.length;e<n;e++){const s=this.coincidents[e];s.sweepLineEntersRing||t.push(s.ringIn)}return t}get isValidEdgeForPoly(){const t="isValidEdgeForPoly";return this._cache[t]===void 0&&(this._cache[t]=this[`_${t}`]()),this._cache[t]}_isValidEdgeForPoly(){let t,e;return this.sweepLineEntersRing?(t=this.getRingsEntering(),e=this.getRingsExiting()):(e=this.getRingsEntering(),t=this.getRingsExiting()),this.ringIn.isValid(t,e,this.ringsInsideOf)}getMultiPolysInsideOf(){const t=[];for(let e=0,n=this.ringsInsideOf.length;e<n;e++){const s=this.ringsInsideOf[e].poly;t.includes(s.multiPoly)||s.isInside(this.getRingsOnEdgeOf(),this.ringsInsideOf)&&t.push(s.multiPoly)}return t}getMultiPolysSLPEnters(t){const e=t.slice();for(let n=0,s=this.coincidents.length;n<s;n++){const r=this.coincidents[n];if(!r.sweepLineEntersPoly)continue;const o=r.ringIn.poly.multiPoly;e.includes(o)||e.push(o)}return e}getMultiPolysSLPExits(t){const e=t.slice();for(let n=0,s=this.coincidents.length;n<s;n++){const r=this.coincidents[n];if(!r.sweepLineExitsPoly)continue;const o=r.ringIn.poly.multiPoly;e.includes(o)||e.push(o)}return e}get isInResult(){const t="isInResult";return this._cache[t]===void 0&&(this._cache[t]=this[`_${t}`]()),this._cache[t]}_isInResult(){if(this!==this.coincidents[0])return!1;const t=this.getMultiPolysInsideOf(),e=this.getMultiPolysSLPEnters(t),n=this.getMultiPolysSLPExits(t);switch(x.type){case x.types.UNION:const s=e.length===0,r=n.length===0;return s!==r;case x.types.INTERSECTION:let o,l;return e.length<n.length?(o=e.length,l=n.length):(o=n.length,l=e.length),l===x.numMultiPolys&&o<l;case x.types.XOR:return Math.abs(e.length-n.length)%2===1;case x.types.DIFFERENCE:const h=c=>c.length===1&&c[0].isSubject;return h(e)!==h(n);default:throw new Error(`Unrecognized operation type found ${x.type}`)}}_clearCache(){this._cache={}}}let kt=0,Q=class{constructor(t,e){this.id=kt++,this.poly=e,this.segments=[];for(let n=1,s=t.length;n<s;n++)this.segments.push(new N(t[n-1],t[n],this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const s=this.segments[e];t.push(s.leftSE),t.push(s.rightSE)}return t}get isExterior(){return this.poly.exteriorRing===this}get isInterior(){return this.poly.exteriorRing!==this}isValid(t,e,n){const s=this.poly.exteriorRing,r=this.poly.interiorRings;if(this===s){for(let o=0,l=n.length;o<l;o++)if(r.includes(n[o]))return!1;for(let o=0,l=t.length;o<l;o++)if(r.includes(t[o]))return!1;return!0}if(!n.includes(s)&&!e.includes(s))return!1;for(let o=0,l=n.length;o<l;o++)if(r.includes(n[o]))return!1;for(let o=0,l=e.length;o<l;o++)if(r.includes(e[o]))return!1;return!0}},Ot=class{constructor(t,e){this.exteriorRing=new Q(t[0],this),this.interiorRings=[];for(let n=1,s=t.length;n<s;n++)this.interiorRings.push(new Q(t[n],this));this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const s=this.interiorRings[e].getSweepEvents();for(let r=0,o=s.length;r<o;r++)t.push(s[r])}return t}isInside(t,e){for(let s=0,r=t.length;s<r;s++)if(t[s].poly===this)return!1;let n=!1;for(let s=0,r=e.length;s<r;s++){const o=e[s];if(o.poly===this){if(o.isInterior)return!1;n=!0}}return n}},At=class{constructor(t){this.polys=[];for(let e=0,n=t.length;e<n;e++)this.polys.push(new Ot(t[e],this));this.isSubject=!1}markAsSubject(){this.isSubject=!0}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const s=this.polys[e].getSweepEvents();for(let r=0,o=s.length;r<o;r++)t.push(s[r])}return t}};class A{static factory(t){const e=[];for(let n=0,s=t.length;n<s;n++){const r=t[n];if(!r.isInResult||r.ringOut)continue;let o=null,l=r.leftSE,u=r.rightSE;const h=[l],c=l.linkedEvents,a=[];for(;o=l,l=u,h.push(l),l.linkedEvents!==c;)for(;;){const f=l.getAvailableLinkedEvents();if(f.length===0){const _=h[0].point,E=h[h.length-1].point;throw new Error(`Unable to complete output ring starting at [${_.x}, ${_.y}]. Last matching segment found ends at  [${E.x}, ${E.y}].`)}if(f.length===1){u=f[0].otherSE;break}let d=null;for(let _=0,E=a.length;_<E;_++)if(a[_].linkedEvents===l.linkedEvents){d=_;break}if(d!==null){const _=a.splice(d)[0],E=h.splice(_.index);E.unshift(E[0].otherSE),e.push(new A(E.reverse()));continue}a.push({index:h.length,linkedEvents:l.linkedEvents});const y=l.getLeftmostComparator(o);u=f.sort(y)[0].otherSE;break}e.push(new A(h))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.registerRingOut(this);this.poly=null,this._clearCache()}registerPoly(t){this.poly=t}getGeom(){const t=[[this.events[0].point.x,this.events[0].point.y]];for(let r=1,o=this.events.length-1;r<o;r++){const l=this.events[r-1].point,u=this.events[r].point,h=this.events[r+1].point;k(u,l,h)!==0&&t.push([u.x,u.y])}const e=this.events[this.events.length-2].point,n=this.events[0].point,s=this.events[1].point;return k(n,e,s)===0&&t.shift(),t.length===0?null:(t.push(t[0]),this.isExteriorRing?t:t.reverse())}get enclosingRing(){return this._getCached("enclosingRing")}get isExteriorRing(){return this._getCached("isExteriorRing")}_clearCache(){this._cache={}}_getCached(t,e){return this._cache[t]===void 0&&(this._cache[t]=this[`_${t}`].bind(this)()),this._cache[t]}_isExteriorRing(){return this.enclosingRing?this.enclosingRing.enclosingRing?this.enclosingRing.enclosingRing.isExteriorRing:!1:!0}_enclosingRing(){let t=this.events[0].segment.prevInResult;for(;t&&t.ringOut===this;)t=t.prevInResult;let e=t?t.prevInResult:null;for(;;){if(!t)return null;if(!e)return t.ringOut;if(e.ringOut!==t.ringOut)return e.ringOut.enclosingRing!==t.ringOut?t.ringOut:t.ringOut.enclosingRing;t=e.prevInResult,e=t?t.prevInResult:null}}}class X{constructor(t){this.exteriorRing=t,t.registerPoly(this),this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.registerPoly(this)}getGeom(){const t=[this.exteriorRing.getGeom()];if(t[0]===null)return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const s=this.interiorRings[e].getGeom();s!==null&&t.push(s)}return t}}class Nt{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const s=this.polys[e].getGeom();s!==null&&t.push(s)}return t}_composePolys(t){const e=[];for(let n=0,s=t.length;n<s;n++){const r=t[n];r.poly||(r.isExteriorRing?e.push(new X(r)):(r.enclosingRing.poly||e.push(new X(r.enclosingRing)),r.enclosingRing.poly.addInterior(r)))}return e}}class q{constructor(t,e){this.key=t,this.data=e,this.left=null,this.right=null}}function Ct(i,t){return i>t?1:i<t?-1:0}function w(i,t,e){if(t===null)return t;let n,s,r;const o=new q;for(n=s=o;;){const l=e(i,t.key);if(l<0){if(t.left===null||e(i,t.left.key)<0&&(r=t.left,t.left=r.right,r.right=t,t=r,t.left===null))break;s.left=t,s=t,t=t.left}else if(l>0){if(t.right===null||e(i,t.right.key)>0&&(r=t.right,t.right=r.left,r.left=t,t=r,t.right===null))break;n.right=t,n=t,t=t.right}else break}return n.right=t.left,s.left=t.right,t.left=o.right,t.right=o.left,t}function D(i,t,e,n,s){const r=new q(i,t);if(s._size++,e===null)return r.left=r.right=null,r;e=w(i,e,n);const o=n(i,e.key);return o<0?(r.left=e.left,r.right=e,e.left=null):o>=0&&(r.right=e.right,r.left=e,e.right=null),r}function Dt(i,t,e,n,s){const r=new q(i,t);if(e===null)return r.left=r.right=null,s._size++,r;e=w(i,e,n);const o=n(i,e.key);return o===0?e:(o<0?(r.left=e.left,r.right=e,e.left=null):o>0&&(r.right=e.right,r.left=e,e.right=null),s._size++,r)}function Y(i,t,e,n){let s;if(t===null)return null;t=w(i,t,e);var r=e(i,t.key);return r===0?(t.left===null?s=t.right:(s=w(i,t.left,e),s.right=t.right),n._size--,s):t}function Z(i,t,e){let n,s;if(t===null)n=s=null;else{t=w(i,t,e);const r=e(t.key,i);r===0?(n=t.left,s=t.right):r<0?(s=t.right,t.right=null,n=t):(n=t.left,t.left=null,s=t)}return{left:n,right:s}}function bt(i,t,e){return t===null?i:(i===null||(t=w(i.key,t,e),t.left=i),t)}function $(i,t,e,n,s){if(i){n(`${t}${e?"└── ":"├── "}${s(i)}
`);const r=t+(e?"    ":"│   ");i.left&&$(i.left,r,!1,n,s),i.right&&$(i.right,r,!0,n,s)}}class Ut{constructor(t=Ct){this._comparator=t,this._root=null,this._size=0}insert(t,e){return this._root=D(t,e,this._root,this._comparator,this)}add(t,e){return this._root=Dt(t,e,this._root,this._comparator,this)}remove(t){this._root=Y(t,this._root,this._comparator,this)}pop(){let t=this._root;if(t){for(;t.left;)t=t.left;return this._root=w(t.key,this._root,this._comparator),this._root=Y(t.key,this._root,this._comparator,this),{key:t.key,data:t.data}}return null}findStatic(t){let e=this._root;const n=this._comparator;for(;e;){const s=n(t,e.key);if(s===0)return e;s<0?e=e.left:e=e.right}return null}find(t){return this._root&&(this._root=w(t,this._root,this._comparator),this._comparator(t,this._root.key)!==0)?null:this._root}contains(t){let e=this._root;const n=this._comparator;for(;e;){const s=n(t,e.key);if(s===0)return!0;s<0?e=e.left:e=e.right}return!1}forEach(t,e){let n=this._root;const s=[];let r=!1;for(;!r;)n!==null?(s.push(n),n=n.left):s.length!==0?(n=s.pop(),t.call(e,n),n=n.right):r=!0;return this}range(t,e,n,s){const r=[],o=this._comparator;let l=this._root,u;for(;r.length!==0||l;)if(l)r.push(l),l=l.left;else{if(l=r.pop(),u=o(l.key,e),u>0)break;if(o(l.key,t)>=0&&n.call(s,l))return this;l=l.right}return this}keys(){const t=[];return this.forEach(({key:e})=>t.push(e)),t}values(){const t=[];return this.forEach(({data:e})=>t.push(e)),t}min(){return this._root?this.minNode(this._root).key:null}max(){return this._root?this.maxNode(this._root).key:null}minNode(t=this._root){if(t)for(;t.left;)t=t.left;return t}maxNode(t=this._root){if(t)for(;t.right;)t=t.right;return t}at(t){let e=this._root,n=!1,s=0;const r=[];for(;!n;)if(e)r.push(e),e=e.left;else if(r.length>0){if(e=r.pop(),s===t)return e;s++,e=e.right}else n=!0;return null}next(t){let e=this._root,n=null;if(t.right){for(n=t.right;n.left;)n=n.left;return n}const s=this._comparator;for(;e;){const r=s(t.key,e.key);if(r===0)break;r<0?(n=e,e=e.left):e=e.right}return n}prev(t){let e=this._root,n=null;if(t.left!==null){for(n=t.left;n.right;)n=n.right;return n}const s=this._comparator;for(;e;){const r=s(t.key,e.key);if(r===0)break;r<0?e=e.left:(n=e,e=e.right)}return n}clear(){return this._root=null,this._size=0,this}toList(){return Ft(this._root)}load(t=[],e=[],n=!1){let s=t.length;const r=this._comparator;if(n&&B(t,e,0,s-1,r),this._root===null)this._root=F(this._root,t,e,0,s),this._size=s;else{const o=zt(this.toList(),$t(t,e),r);s=this._size+s,this._root=z({head:o},0,s)}return this}isEmpty(){return this._root===null}get size(){return this._size}toString(t=e=>e.key){const e=[];return $(this._root,"",!0,n=>e.push(n),t),e.join("")}update(t,e,n){const s=this._comparator;let{left:r,right:o}=Z(t,this._root,s);this._size--,s(t,e)<0?o=D(e,n,o,s,this):r=D(e,n,r,s,this),this._root=bt(r,o,s)}split(t){return Z(t,this._root,this._comparator)}}function F(i,t,e,n,s){const r=s-n;if(r>0){const o=n+Math.floor(r/2),l=t[o],u=e[o],h={key:l,data:u,parent:i};return h.left=F(h,t,e,n,o),h.right=F(h,t,e,o+1,s),h}return null}function $t(i,t){const e={next:null};let n=e;for(let s=0;s<i.length;s++)n=n.next={key:i[s],data:t[s]};return n.next=null,e.next}function Ft(i){var t=i,e=[],n=!1;const s={next:null};let r=s;for(;!n;)t?(e.push(t),t=t.left):e.length>0?(t=r=r.next=e.pop(),t=t.right):n=!0;return r.next=null,s.next}function z(i,t,e){const n=e-t;if(n>0){const s=t+Math.floor(n/2),r=z(i,t,s),o=i.head;return o.left=r,i.head=i.head.next,o.right=z(i,s+1,e),o}return null}function zt(i,t,e=(n,s)=>n-s){const n={};let s=n,r=i,o=t;for(;r!==null&&o!==null;)e(r.key,o.key)<0?(s.next=r,r=r.next):(s.next=o,o=o.next),s=s.next;return r!==null?s.next=r:o!==null&&(s.next=o),n.next}function B(i,t,e,n,s){if(e>=n)return;const r=i[e+n>>1];let o=e-1,l=n+1;for(;;){do o++;while(s(i[o],r)<0);do l--;while(s(i[l],r)>0);if(o>=l)break;let u=i[o];i[o]=i[l],i[l]=u,u=t[o],t[o]=t[l],t[l]=u}B(i,t,e,l,s),B(i,t,l+1,n,s)}class Bt{constructor(t=N.compare){this.tree=new Ut(t),this.segments=[],this.prevEvent=null}process(t){const e=t.segment,n=[],s=t.isLeft?this.tree.insert(e):this.tree.find(e),r=this.tree.prev(s),o=r?r.key:null,l=this.tree.next(s),u=l?l.key:null;if(t.isLeft){const h=[];if(o){const c=o.getIntersections(e);if(c.length>0){const a=this._possibleSplit(o,c);for(let f=0,d=a.length;f<d;f++)n.push(a[f]);for(let f=0,d=c.length;f<d;f++){const y=c[f];e.isAnEndpoint(y)||h.push(y)}}}if(u){const c=u.getIntersections(e);if(c.length>0){const a=this._possibleSplit(u,c);for(let f=0,d=a.length;f<d;f++)n.push(a[f]);for(let f=0,d=c.length;f<d;f++){const y=c[f];e.isAnEndpoint(y)||h.push(y)}}}if(n.length>0||h.length>0){if(this.tree.remove(e),h.length>0){const c=e.split(h);for(let a=0,f=c.length;a<f;a++)n.push(c[a])}return n.push(t),n}this.segments.push(e),e.registerPrev(o)}else{if(o&&u){const h=o.getIntersections(u);if(h.length>0){let c=this._possibleSplit(o,h);for(let a=0,f=c.length;a<f;a++)n.push(c[a]);c=this._possibleSplit(u,h);for(let a=0,f=c.length;a<f;a++)n.push(c[a])}}this.tree.remove(e)}return this.prevEvent&&v(this.prevEvent.point,t.point)===0&&this.prevEvent.link(t),this.prevEvent=t,n}_possibleSplit(t,e){const n=[];for(let r=0,o=e.length;r<o;r++){const l=e[r];t.isAnEndpoint(l)||n.push(l)}let s;return n.length>0?(this.tree.remove(t),s=t.split(n),this.tree.insert(t)):s=[],s}}function et(i,t,e){const n=[H(t)];for(let h=0,c=e.length;h<c;h++)n.push(H(e[h]));for(let h=0,c=n.length;h<c;h++)vt(n[h]),wt(n[h]);const s=[];for(let h=0,c=n.length;h<c;h++)s.push(new At(n[h]));s[0].markAsSubject(),x.register(i,s.length);const r=new mt({comparBefore:P.compareBefore});for(let h=0,c=s.length;h<c;h++){const a=s[h].getSweepEvents();for(let f=0,d=a.length;f<d;f++)r.insert(a[f])}const o=new Bt;for(;r.length;){const h=o.process(r.remove());for(let c=0,a=h.length;c<a;c++)r.insert(h[c])}St(o.segments);const l=A.factory(o.segments);return new Nt(l).getGeom()}const Gt=(i,...t)=>et(x.types.UNION,i,t),Tt=(i,...t)=>et(x.types.DIFFERENCE,i,t);function qt(i,t){var e,n,s,r,o,l,u,h,c,a,f=0,d=i.type==="FeatureCollection",y=i.type==="Feature",_=d?i.features.length:1;for(e=0;e<_;e++){for(l=d?i.features[e].geometry:y?i.geometry:i,h=d?i.features[e].properties:y?i.properties:{},c=d?i.features[e].bbox:y?i.bbox:void 0,a=d?i.features[e].id:y?i.id:void 0,u=l?l.type==="GeometryCollection":!1,o=u?l.geometries.length:1,s=0;s<o;s++){if(r=u?l.geometries[s]:l,r===null){if(t(null,f,h,c,a)===!1)return!1;continue}switch(r.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":{if(t(r,f,h,c,a)===!1)return!1;break}case"GeometryCollection":{for(n=0;n<r.geometries.length;n++)if(t(r.geometries[n],f,h,c,a)===!1)return!1;break}default:throw new Error("Unknown Geometry Type")}}f++}}function jt(i){const t=[];qt(i,function(n){n.type==="Polygon"?t.push(n.coordinates):n.coordinates.forEach(function(s){t.push(s)})});var e=Gt(t);return e.length===0?null:K(e)}function Vt(i,t){var e=V(i),n=V(t),s=i.properties||{},r=Tt(e.coordinates,n.coordinates);return r.length===0?null:K(r,s)}let b={circle:gt,union:jt,difference:Vt};let it,nt,R,G;W.subscribe(i=>{R=i});rt.subscribe(i=>{G=i.data});ot.subscribe(i=>{it=i.color,nt=i.id});const Ht=L.Control.extend({options:{position:"topright",radius:30,minRadius:10,maxRadius:50,layerOptions:{weight:1},drawOptions:{weight:1},eraseOptions:{color:"#ff324a",weight:1},menu:{drawErase:!0,size:!0,eraseAll:!0}},_latlng:[0,0],_metersPerPixel:{},onAdd:function(i){return this._map=i,this.setRadius(this.options.radius),R.forEach(t=>{L.geoJSON(t.geometry,{color:G[G.findIndex(e=>e.id===t.properties.label)].color,style:{weight:1}}).addTo(i)}),this.options.menu===!1?L.DomUtil.create("div"):(this._container=L.DomUtil.create("div","leaflet-control-paintpolygon leaflet-bar leaflet-control"),this._createMenu(),this._container)},onRemove:function(){this._resetMenu(),this.stop(),this._data&&this._map.removeLayer(this._data),this._map.off("mousemove",this._onMouseMove,this)},setRadius:function(i){i!==void 0&&(i<this.options.minRadius?this._radius=this.options.minRadius:i>this.options.maxRadius?this._radius=this.options.maxRadius:this._radius=i),this._circle&&this._circle.setRadius(this._radius)},startDraw:function(){this.stop(),this._action="draw",this._addMouseListener(),this._circle=L.circleMarker(this._latlng,this.options.drawOptions).setRadius(this._radius).addTo(this._map)},startErase:function(){this.stop(),this._action="erase",this._addMouseListener(),this._circle=L.circleMarker(this._latlng,this.options.eraseOptions).setRadius(this._radius).addTo(this._map)},stop:function(){this._action=null,this._circle&&this._circle.remove(),this._removeMouseListener()},getLayer:function(){return this._layer},setData:function(i){this._data=i,this._layer!==void 0&&this._layer.remove(),this._layer=L.geoJSON(this._data,{weight:1,color:it}).addTo(this._map)},getData:function(){if(!this._data){console.log("Nothing to save");return}return this._data.properties={id:+L.Util.lastId+1,label:nt},W.set([...R,this._data]),console.log(R),this._data},eraseAll:function(){this.setData()},_createMenu:function(){if(this.options.menu.drawErase!==!1&&(this._iconDraw=L.DomUtil.create("a","leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-brush",this._container),this._iconErase=L.DomUtil.create("a","leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-eraser",this._container),L.DomEvent.on(this._iconDraw,"click mousedown",this._clickDraw,this),L.DomEvent.on(this._iconErase,"click mousedown",this._clickErase,this),L.DomEvent.on(this._container,"dblclick",this._stopEventPropagation,this)),this.options.menu.size!==!1){this._iconSize=L.DomUtil.create("a","leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-size",this._container),this._menu=L.DomUtil.create("div","leaflet-bar leaflet-control-paintpolygon-menu",this._container),L.DomEvent.disableClickPropagation(this._menu);var i=L.DomUtil.create("div","leaflet-control-paintpolygon-menu-content",this._menu),t=L.DomUtil.create("input","",i);t.type="range",t.value=this._radius,t.min=this.options.minRadius,t.max=this.options.maxRadius,L.DomEvent.on(t,"input change",this._cursorMove,this),L.DomEvent.on(this._iconSize,"click mousedown",this._clickSize,this)}this.options.menu.eraseAll!==!1&&(this._iconEraseAll=L.DomUtil.create("a","leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-trash leaflet-disabled",this._container),L.DomEvent.on(this._iconEraseAll,"click mousedown",this._clickEraseAll,this)),this._iconSave=L.DomUtil.create("a","leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-save leaflet-disabled",this._container),L.DomEvent.on(this._iconSave,"click mousedown",this._clickSave,this)},_stopEventPropagation:function(i){if(i.type=="dblclick"){i.stopPropagation();return}},_clickDraw:function(i){if(L.DomUtil.hasClass(this._menu,"leaflet-control-paintpolygon-menu-open")&&this._closeMenu(),i.type=="mousedown"){L.DomEvent.stop(i);return}this._resetMenu(),this._action=="draw"?this.stop():(this.startDraw(),this._activeIconStyle(this._iconDraw))},_clickErase:function(i){if(L.DomUtil.hasClass(this._menu,"leaflet-control-paintpolygon-menu-open")&&this._closeMenu(),i.type=="mousedown"){L.DomEvent.stop(i);return}this._resetMenu(),this._action=="erase"?this.stop():(this.startErase(),this._activeIconStyle(this._iconErase))},_clickSize:function(i){if(i.type=="mousedown"){L.DomEvent.stop(i);return}L.DomUtil.hasClass(this._menu,"leaflet-control-paintpolygon-menu-open")?this._closeMenu():this._openMenu()},_clickEraseAll:function(i){if(L.DomUtil.hasClass(this._menu,"leaflet-control-paintpolygon-menu-open")&&this._closeMenu(),i.type=="mousedown"){L.DomEvent.stop(i);return}this.eraseAll()},_clickSave:function(i){if(L.DomUtil.hasClass(this._menu,"leaflet-control-paintpolygon-menu-open")&&this._closeMenu(),i.type=="mousedown"){L.DomEvent.stop(i);return}this.getData()},_resetMenu:function(){L.DomUtil.removeClass(this._iconDraw,"leaflet-control-paintpolygon-icon-active"),L.DomUtil.removeClass(this._iconErase,"leaflet-control-paintpolygon-icon-active")},_activeIconStyle:function(i){L.DomUtil.addClass(i,"leaflet-control-paintpolygon-icon-active")},_openMenu:function(){L.DomUtil.addClass(this._menu,"leaflet-control-paintpolygon-menu-open")},_closeMenu:function(){L.DomUtil.removeClass(this._menu,"leaflet-control-paintpolygon-menu-open")},_cursorMove:function(i){this.setRadius(i.target.valueAsNumber)},_addMouseListener:function(){this._map.on("mousemove",this._onMouseMove,this),this._map.on("mousedown",this._onMouseDown,this),this._map.on("mouseup",this._onMouseUp,this)},_removeMouseListener:function(){this._map.off("mousemove",this._onMouseMove,this),this._map.off("mousedown",this._onMouseDown,this),this._map.off("mouseup",this._onMouseUp,this)},_onMouseDown:function(i){L.DomUtil.hasClass(this._menu,"leaflet-control-paintpolygon-menu-open")&&this._closeMenu(),this._map.dragging.disable(),this._mousedown=!0,this._onMouseMove(i)},_onMouseUp:function(i){this._map.dragging.enable(),this._mousedown=!1},_onMouseMove:function(i){this._setLatLng(i.latlng),this._mousedown===!0&&this._stackEvt(i.latlng,this._map.getZoom(),this._radius,this._action)},_setLatLng:function(i){i!==void 0&&(this._latlng=i),this._circle&&this._circle.setLatLng(this._latlng)},_latLngAsGeoJSON:function(i){return{type:"Point",coordinates:[i.lng,i.lat]}},_getCircleAsPolygon:function(i,t,e){var n=i.lat;return this._metersPerPixel[t]===void 0&&(this._metersPerPixel[t]=40075016686e-3*Math.abs(Math.cos(n*Math.PI/180))/Math.pow(2,t+8)),b.circle(this._latLngAsGeoJSON(i),this._metersPerPixel[t]*e/1e3,{})},_draw:function(i,t,e){if(this._data===void 0||this._data===null)this.setData(this._getCircleAsPolygon(i,t,e));else{let n={type:"FeatureCollection",features:[this._data,this._getCircleAsPolygon(i,t,e)]};this.setData(b.union(n))}},_erase:function(i,t,e){this._data===void 0||this._data===null||this.setData(b.difference(this._data,this._getCircleAsPolygon(i,t,e)))},_stackEvt:function(i,t,e,n){this._stack===void 0&&(this._stack=new Array),this._stack.push({latlng:i,zoom:t,radius:e,action:n}),this._processStack()},_processStack:function(){if(!(this._processingStack===!0||this._stack.length==0)){this._processingStack=!0;var i=this._stack.shift();i.action=="draw"?this._draw(i.latlng,i.zoom,i.radius):i.action=="erase"&&this._erase(i.latlng,i.zoom,i.radius),this._processingStack=!1,this._processStack()}}});L.Control.PaintPolygon=Ht;L.control.paintPolygon=i=>new L.Control.PaintPolygon(i);export{Ht as default};
