from abc import abstractmethod
from enum import Enum
from typing import Any, Iterable, NamedTuple, Protocol

from dbsamizdat.exceptions import UnsuitableNameError

PG_IDENTIFIER_MAXLEN = 63
PG_IDENTIFIER_VERBOTEN = set('"')
# Actually allowed, but we'd have to escape it everywhere.
# See https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS
# Autogenerated triggers are numbered so as to make them run in samizdat dependency
# order when sorted alphabetically
# (as that's how PostgreSQL determines trigger run order). For this we need to leftpad
# the numbers (because 166 < 23, but 166 > 023, alphabetically)
# Sadly, this poses an artificial limit on the trigger "depth" and an exception will
# be raised if this is exceeded.
# The size here is chosen to retain short-ish trigger names without running into problems
# all too soon.


class entitypes(Enum):
    UNDEFINED = "UNDEFINED"
    VIEW = "VIEW"
    MATVIEW = "MATERIALIZED VIEW"
    FUNCTION = "FUNCTION"
    TRIGGER = "TRIGGER"


class FQTuple(NamedTuple):
    schema: str
    object_name: str
    args: str | None = None


class HasFQ(Protocol):
    """
    Ability to "fully qualify" oneself as a postgres instance
    """

    @classmethod
    def fq(cls) -> FQTuple:
        ...


objectname = str
schemaname = str
sql_query = str
# Already a "FQ"; or, something which can give its own FQ


class HasFQify(Protocol):
    @classmethod
    def fqify(cls, ref: HasFQ) -> FQTuple:
        ...


class HasRefreshTriggers(HasFQ, HasFQify):
    """
    Optional extras for refreshing a view on table changes
    """

    refresh_triggers: set["FQIffable"] = set()

    @classmethod
    def fqrefresh_triggers(cls):
        return {cls.fqify(trigger) for trigger in cls.refresh_triggers}


class ProtoSamizdat(HasFQ, HasFQify):
    deps_on: set["FQIffable"] = set()
    deps_on_unmanaged: set["FQIffable"] = set()
    schema: schemaname | None = "public"
    sql_template: sql_query = """
        -- There should be a class-dependent body for ${samizdatname} here.
        -- See README.md.
        """
    entity_type: entitypes

    @classmethod
    @abstractmethod
    def get_name(cls) -> str:
        return cls.__name__

    @classmethod
    @abstractmethod
    def db_object_identity(cls) -> str:
        ...

    @classmethod
    @abstractmethod
    def validate_name(cls):
        """
        Check whether name is a valid PostgreSQL identifier. Note that we'll quote
        the identifier everywhere ("quoted identifier" per
        https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS)
        """
        name = cls.get_name()
        for char in name:
            if ord(char) > 0x7F:
                raise UnsuitableNameError("Name contains non-ASCII characters", samizdat=cls)
        # Technically we could UESCAPE these,
        # and make the length calculation much more complicated.
        if len(name) > PG_IDENTIFIER_MAXLEN:
            raise UnsuitableNameError("Name is too long", samizdat=cls)
        if set(name) & PG_IDENTIFIER_VERBOTEN:
            badchars = {set(name) & PG_IDENTIFIER_VERBOTEN}
            raise UnsuitableNameError(
                f"""Name contains unwelcome characters ({badchars})""",
                samizdat=cls,
            )

    @classmethod
    @abstractmethod
    def definition_hash(cls):
        """
        Return the "implanted" hash if preset or generate
        a new descriptive hash of this instance
        """
        ...

    @classmethod
    @abstractmethod
    def fqdeps_on(cls) -> set[FQTuple]:
        ...

    @classmethod
    @abstractmethod
    def fqdeps_on_unmanaged(cls) -> set[FQTuple]:
        ...

    @classmethod
    @abstractmethod
    def dbinfo(cls):
        """
        Returns descriptor (json) for this object, to be stored in the database
        """
        ...

    @classmethod
    @abstractmethod
    def sign(cls, cursor: "Mogrifier") -> sql_query:
        """
        Generate COMMENT ON sql storing a signature
        We need the cursor to let psycopg (2) properly escape our json-as-text-string.
        """
        ...

    @classmethod
    @abstractmethod
    def create(cls) -> sql_query:
        """
        SQL to create this DB object
        """
        ...

    @classmethod
    @abstractmethod
    def drop(cls, if_exists: bool) -> sql_query:
        """
        SQL to drop object. Cascade because we have no idea about the dependency tree.
        """
        ...

    @classmethod
    @abstractmethod
    def and_sidekicks(cls) -> Iterable["ProtoSamizdat"]:
        """
        On some classes, this will yield autogenerated sidekick classes
        """
        ...

    @classmethod
    @abstractmethod
    def head_id(cls) -> str:
        ...


FQIffable = FQTuple | HasFQ | str | ProtoSamizdat | tuple[str, ...]


class Mogrifier(Protocol):
    """
    A class which can "mogrify" a SQL string
    """

    @abstractmethod
    def mogrify(self, *args, **kwargs) -> str | bytes:
        ...

    @property
    def connection(self) -> Any:
        ...


class Cursor(Mogrifier):
    """
    Approximately define what you need in a 'cursor' class
    """

    def execute(self, str) -> None:
        ...

    def close(self) -> None:
        ...

    @abstractmethod
    def fetchall(self) -> list:
        ...
